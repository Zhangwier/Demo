Help on package arcade:

NAME
    arcade - The Arcade Library

DESCRIPTION
    A Python simple, easy to use module for creating 2D games.

PACKAGE CONTENTS
    __pyinstaller (package)
    application
    arcade_types
    buffered_draw_commands
    color (package)
    context
    csscolor (package)
    draw_commands
    drawing_support
    earclip_module
    emitter
    emitter_simple
    examples (package)
    experimental (package)
    geometry
    gl (package)
    gui (package)
    isometric
    joysticks
    key (package)
    particle
    paths
    physics_engines
    pymunk_physics_engine
    resources (package)
    soloud (package)
    sound
    sprite
    sprite_list
    text
    texture
    tilemap
    utils
    version
    window_commands

CLASSES
    arcade.gl.context.Context(builtins.object)
        arcade.context.ArcadeContext
    builtins.Exception(builtins.BaseException)
        arcade.application.NoOpenGLException
    builtins.object
        arcade.application.View
        arcade.buffered_draw_commands.Shape
        arcade.emitter.EmitController
            arcade.emitter.EmitBurst
            arcade.emitter.EmitInterval
                arcade.emitter.EmitterIntervalWithCount
                arcade.emitter.EmitterIntervalWithTime
            arcade.emitter.EmitMaintainCount
        arcade.emitter.Emitter
        arcade.paths.AStarBarrierList
        arcade.physics_engines.PhysicsEnginePlatformer
        arcade.physics_engines.PhysicsEngineSimple
        arcade.pymunk_physics_engine.PymunkPhysicsEngine
        arcade.pymunk_physics_engine.PymunkPhysicsObject
        arcade.sound.Sound
        arcade.sprite.AnimationKeyframe
        arcade.sprite.PyMunk
        arcade.sprite.Sprite
            arcade.particle.Particle
                arcade.particle.EternalParticle
                arcade.particle.LifetimeParticle
                    arcade.particle.FadeParticle
            arcade.sprite.AnimatedTimeBasedSprite
            arcade.sprite.AnimatedTimeSprite
            arcade.sprite.AnimatedWalkingSprite
            arcade.sprite.SpriteCircle
            arcade.sprite.SpriteSolidColor
        arcade.sprite_list.SpriteList
        arcade.text.CreateText
        arcade.text.Text
        arcade.texture.Matrix3x3
        arcade.texture.Texture
    builtins.tuple(builtins.object)
        arcade.arcade_types.Point
    pyglet.window.win32.Win32Window(pyglet.window.BaseWindow)
        arcade.application.Window
    typing.Generic(builtins.object)
        arcade.buffered_draw_commands.ShapeElementList
    
    class AStarBarrierList(builtins.object)
     |  AStarBarrierList(moving_sprite: arcade.sprite.Sprite, blocking_sprites: arcade.sprite_list.SpriteList, grid_size: int, left: int, right: int, bottom: int, top: int)
     |  
     |  Class that manages a list of barriers that can be encountered during
     |  A* path finding.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, moving_sprite: arcade.sprite.Sprite, blocking_sprites: arcade.sprite_list.SpriteList, grid_size: int, left: int, right: int, bottom: int, top: int)
     |      :param Sprite moving_sprite: Sprite that will be moving
     |      :param SpriteList blocking_sprites: Sprites that can block movement
     |      :param int grid_size: Size of the grid, in pixels
     |      :param int left: Left border of playing field
     |      :param int right: Right border of playing field
     |      :param int bottom: Bottom of playing field
     |      :param int top: Top of playing field
     |  
     |  recalculate(self)
     |      Recalculate blocking sprites.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class AnimatedTimeBasedSprite(Sprite)
     |  AnimatedTimeBasedSprite(filename: str = None, scale: float = 1, image_x: float = 0, image_y: float = 0, image_width: float = 0, image_height: float = 0, center_x: float = 0, center_y: float = 0, _repeat_count_x=1, _repeat_count_y=1)
     |  
     |  Sprite for platformer games that supports animations. These can
     |  be automatically created by the Tiled Map Editor.
     |  
     |  Method resolution order:
     |      AnimatedTimeBasedSprite
     |      Sprite
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, filename: str = None, scale: float = 1, image_x: float = 0, image_y: float = 0, image_width: float = 0, image_height: float = 0, center_x: float = 0, center_y: float = 0, _repeat_count_x=1, _repeat_count_y=1)
     |      Create a new sprite.
     |      
     |      :param str filename: Filename of an image that represents the sprite.
     |      :param float scale: Scale the image up or down. Scale of 1.0 is none.
     |      :param float image_x: X offset to sprite within sprite sheet.
     |      :param float image_y: Y offset to sprite within sprite sheet.
     |      :param float image_width: Width of the sprite
     |      :param float image_height: Height of the sprite
     |      :param float center_x: Location of the sprite
     |      :param float center_y: Location of the sprite
     |      :param bool flipped_horizontally: Mirror the sprite image. Flip left/right across vertical axis.
     |      :param bool flipped_vertically: Flip the image up/down across the horizontal axis.
     |      :param bool flipped_diagonally: Transpose the image, flip it across the diagonal.
     |      :param mirrored: Deprecated.
     |      :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.         Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,         :data:`PhysicsEnginePlatformer`         and 'Detailed' for the :data:`PymunkPhysicsEngine`.
     |      
     |          .. figure:: images/hit_box_algorithm_none.png
     |             :width: 40%
     |      
     |             hit_box_algorithm = "None"
     |      
     |          .. figure:: images/hit_box_algorithm_simple.png
     |             :width: 55%
     |      
     |             hit_box_algorithm = "Simple"
     |      
     |          .. figure:: images/hit_box_algorithm_detailed.png
     |             :width: 75%
     |      
     |             hit_box_algorithm = "Detailed"
     |      :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Logic for selecting the proper texture to use.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Sprite:
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  add_spatial_hashes(self)
     |      Add spatial hashes for this sprite in all the sprite lists it is part of.
     |  
     |  append_texture(self, texture: arcade.texture.Texture)
     |      Appends a new texture to the list of textures that can be
     |      applied to this sprite.
     |      
     |      :param arcade.Texture texture: Texture to add ot the list of available textures
     |  
     |  clear_spatial_hashes(self)
     |      Search the sprite lists this sprite is a part of, and remove it
     |      from any spatial hashes it is a part of.
     |  
     |  collides_with_list(self, sprite_list: 'SpriteList') -> list
     |      Check if current sprite is overlapping with any other sprite in a list
     |      
     |      Args:
     |          self: current Sprite
     |          sprite_list: SpriteList to check against
     |      
     |      Returns:
     |          SpriteList of all overlapping Sprites from the original SpriteList
     |  
     |  collides_with_point(self, point: Union[Tuple[float, float], List[float]]) -> bool
     |      Check if point is within the current sprite.
     |      
     |      Args:
     |          self: Current sprite
     |          point: Point to check.
     |      
     |      Returns:
     |          True if the point is contained within the sprite's boundary.
     |  
     |  collides_with_sprite(self, other: 'Sprite') -> bool
     |      Will check if a sprite is overlapping (colliding) another Sprite.
     |      
     |      Args:
     |          self: Current Sprite.
     |          other: The other sprite to check against.
     |      
     |      Returns:
     |          True or False, whether or not they are overlapping.
     |  
     |  draw(self)
     |      Draw the sprite.
     |  
     |  draw_hit_box(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0), line_thickness: float = 1)
     |      Draw a sprite's hit-box.
     |      
     |      The 'hit box' drawing is cached, so if you change the color/line thickness
     |      later, it won't take.
     |      
     |      :param color: Color of box
     |      :param line_thickness: How thick the box should be
     |  
     |  forward(self, speed: float = 1.0)
     |      Set a Sprite's position to speed by its angle
     |      :param speed: speed factor
     |  
     |  get_adjusted_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  get_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  get_points(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  kill(self)
     |      Alias of `remove_from_sprite_lists`
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pymunk_moved(self, physics_engine, dx, dy, d_angle)
     |      Called by the pymunk physics engine if this sprite moves.
     |  
     |  register_physics_engine(self, physics_engine)
     |      Called by the Pymunk physics engine when this sprite is added
     |      to that physics engine. Lets the sprite know about the engine and
     |      remove itself if it gets deleted.
     |  
     |  register_sprite_list(self, new_list)
     |      Register this sprite as belonging to a list. We will automatically
     |      remove ourselves from the the list when kill() is called.
     |  
     |  remove_from_sprite_lists(self)
     |      Remove the sprite from all sprite lists.
     |  
     |  rescale_relative_to_point(self, point: Union[Tuple[float, float], List[float]], factor: float) -> None
     |      Rescale the sprite relative to a different point than its center.
     |  
     |  reverse(self, speed: float = 1.0)
     |      Set a new speed, but in reverse.
     |      :param speed: speed factor
     |  
     |  set_hit_box(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hit box. Hit box should be relative to a sprite's center,
     |      and with a scale of 1.0.
     |      Points will be scaled with get_adjusted_hit_box.
     |  
     |  set_points(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hitbox
     |  
     |  set_position(self, center_x: float, center_y: float)
     |      Set a sprite's position
     |      
     |      :param float center_x: New x position of sprite
     |      :param float center_y: New y position of sprite
     |  
     |  set_texture(self, texture_no: int)
     |      Sets texture by texture id. Should be renamed because it takes
     |      a number rather than a texture, but keeping
     |      this for backwards compatibility.
     |  
     |  stop(self)
     |      Stop the Sprite's motion
     |  
     |  strafe(self, speed: float = 1.0)
     |      Set a sprites position perpendicular to its angle by speed
     |      :param speed: speed factor
     |  
     |  turn_left(self, theta: float = 90)
     |      Rotate the sprite left a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  turn_right(self, theta: float = 90)
     |      Rotate the sprite right a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  update(self)
     |      Update the sprite.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Sprite:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  alpha
     |      Return the alpha associated with the sprite.
     |  
     |  angle
     |      Get the angle of the sprite's rotation.
     |  
     |  bottom
     |      Return the y coordinate of the bottom of the sprite.
     |  
     |  center_x
     |      Get the center x coordinate of the sprite.
     |  
     |  center_y
     |      Get the center y coordinate of the sprite.
     |  
     |  change_x
     |      Get the velocity in the x plane of the sprite.
     |  
     |  change_y
     |      Get the velocity in the y plane of the sprite.
     |  
     |  collision_radius
     |      Get the collision radius.
     |      
     |      .. note:: Final collision checking is done via geometry that was
     |          set in get_points/set_points. These points are used in the
     |          check_for_collision function. This collision_radius variable
     |          is used as a "pre-check." We do a super-fast check with
     |          collision_radius and see if the sprites are close. If they are,
     |          then we look at the geometry and figure if they really are colliding.
     |  
     |  color
     |      Return the RGB color associated with the sprite.
     |  
     |  height
     |      Get the height in pixels of the sprite.
     |  
     |  hit_box
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  left
     |      Return the x coordinate of the left-side of the sprite's hit box.
     |  
     |  points
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  position
     |      Get the center x and y coordinates of the sprite.
     |      
     |      Returns:
     |          (center_x, center_y)
     |  
     |  radians
     |      Converts the degrees representation of self.angle into radians.
     |      :return: float
     |  
     |  right
     |      Return the x coordinate of the right-side of the sprite's hit box.
     |  
     |  scale
     |      Get the scale of the sprite.
     |  
     |  texture
     |  
     |  texture_transform
     |  
     |  top
     |      Return the y coordinate of the top of the sprite.
     |  
     |  width
     |      Get the width of the sprite.
    
    class AnimatedTimeSprite(Sprite)
     |  AnimatedTimeSprite(scale: float = 1, image_x: float = 0, image_y: float = 0, center_x: float = 0, center_y: float = 0)
     |  
     |  Deprecated class for periodically updating sprite animations. Use
     |  AnimatedTimeBasedSprite instead.
     |  
     |  Method resolution order:
     |      AnimatedTimeSprite
     |      Sprite
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, scale: float = 1, image_x: float = 0, image_y: float = 0, center_x: float = 0, center_y: float = 0)
     |      Create a new sprite.
     |      
     |      :param str filename: Filename of an image that represents the sprite.
     |      :param float scale: Scale the image up or down. Scale of 1.0 is none.
     |      :param float image_x: X offset to sprite within sprite sheet.
     |      :param float image_y: Y offset to sprite within sprite sheet.
     |      :param float image_width: Width of the sprite
     |      :param float image_height: Height of the sprite
     |      :param float center_x: Location of the sprite
     |      :param float center_y: Location of the sprite
     |      :param bool flipped_horizontally: Mirror the sprite image. Flip left/right across vertical axis.
     |      :param bool flipped_vertically: Flip the image up/down across the horizontal axis.
     |      :param bool flipped_diagonally: Transpose the image, flip it across the diagonal.
     |      :param mirrored: Deprecated.
     |      :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.         Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,         :data:`PhysicsEnginePlatformer`         and 'Detailed' for the :data:`PymunkPhysicsEngine`.
     |      
     |          .. figure:: images/hit_box_algorithm_none.png
     |             :width: 40%
     |      
     |             hit_box_algorithm = "None"
     |      
     |          .. figure:: images/hit_box_algorithm_simple.png
     |             :width: 55%
     |      
     |             hit_box_algorithm = "Simple"
     |      
     |          .. figure:: images/hit_box_algorithm_detailed.png
     |             :width: 75%
     |      
     |             hit_box_algorithm = "Detailed"
     |      :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Logic for selecting the proper texture to use.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Sprite:
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  add_spatial_hashes(self)
     |      Add spatial hashes for this sprite in all the sprite lists it is part of.
     |  
     |  append_texture(self, texture: arcade.texture.Texture)
     |      Appends a new texture to the list of textures that can be
     |      applied to this sprite.
     |      
     |      :param arcade.Texture texture: Texture to add ot the list of available textures
     |  
     |  clear_spatial_hashes(self)
     |      Search the sprite lists this sprite is a part of, and remove it
     |      from any spatial hashes it is a part of.
     |  
     |  collides_with_list(self, sprite_list: 'SpriteList') -> list
     |      Check if current sprite is overlapping with any other sprite in a list
     |      
     |      Args:
     |          self: current Sprite
     |          sprite_list: SpriteList to check against
     |      
     |      Returns:
     |          SpriteList of all overlapping Sprites from the original SpriteList
     |  
     |  collides_with_point(self, point: Union[Tuple[float, float], List[float]]) -> bool
     |      Check if point is within the current sprite.
     |      
     |      Args:
     |          self: Current sprite
     |          point: Point to check.
     |      
     |      Returns:
     |          True if the point is contained within the sprite's boundary.
     |  
     |  collides_with_sprite(self, other: 'Sprite') -> bool
     |      Will check if a sprite is overlapping (colliding) another Sprite.
     |      
     |      Args:
     |          self: Current Sprite.
     |          other: The other sprite to check against.
     |      
     |      Returns:
     |          True or False, whether or not they are overlapping.
     |  
     |  draw(self)
     |      Draw the sprite.
     |  
     |  draw_hit_box(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0), line_thickness: float = 1)
     |      Draw a sprite's hit-box.
     |      
     |      The 'hit box' drawing is cached, so if you change the color/line thickness
     |      later, it won't take.
     |      
     |      :param color: Color of box
     |      :param line_thickness: How thick the box should be
     |  
     |  forward(self, speed: float = 1.0)
     |      Set a Sprite's position to speed by its angle
     |      :param speed: speed factor
     |  
     |  get_adjusted_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  get_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  get_points(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  kill(self)
     |      Alias of `remove_from_sprite_lists`
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pymunk_moved(self, physics_engine, dx, dy, d_angle)
     |      Called by the pymunk physics engine if this sprite moves.
     |  
     |  register_physics_engine(self, physics_engine)
     |      Called by the Pymunk physics engine when this sprite is added
     |      to that physics engine. Lets the sprite know about the engine and
     |      remove itself if it gets deleted.
     |  
     |  register_sprite_list(self, new_list)
     |      Register this sprite as belonging to a list. We will automatically
     |      remove ourselves from the the list when kill() is called.
     |  
     |  remove_from_sprite_lists(self)
     |      Remove the sprite from all sprite lists.
     |  
     |  rescale_relative_to_point(self, point: Union[Tuple[float, float], List[float]], factor: float) -> None
     |      Rescale the sprite relative to a different point than its center.
     |  
     |  reverse(self, speed: float = 1.0)
     |      Set a new speed, but in reverse.
     |      :param speed: speed factor
     |  
     |  set_hit_box(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hit box. Hit box should be relative to a sprite's center,
     |      and with a scale of 1.0.
     |      Points will be scaled with get_adjusted_hit_box.
     |  
     |  set_points(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hitbox
     |  
     |  set_position(self, center_x: float, center_y: float)
     |      Set a sprite's position
     |      
     |      :param float center_x: New x position of sprite
     |      :param float center_y: New y position of sprite
     |  
     |  set_texture(self, texture_no: int)
     |      Sets texture by texture id. Should be renamed because it takes
     |      a number rather than a texture, but keeping
     |      this for backwards compatibility.
     |  
     |  stop(self)
     |      Stop the Sprite's motion
     |  
     |  strafe(self, speed: float = 1.0)
     |      Set a sprites position perpendicular to its angle by speed
     |      :param speed: speed factor
     |  
     |  turn_left(self, theta: float = 90)
     |      Rotate the sprite left a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  turn_right(self, theta: float = 90)
     |      Rotate the sprite right a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  update(self)
     |      Update the sprite.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Sprite:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  alpha
     |      Return the alpha associated with the sprite.
     |  
     |  angle
     |      Get the angle of the sprite's rotation.
     |  
     |  bottom
     |      Return the y coordinate of the bottom of the sprite.
     |  
     |  center_x
     |      Get the center x coordinate of the sprite.
     |  
     |  center_y
     |      Get the center y coordinate of the sprite.
     |  
     |  change_x
     |      Get the velocity in the x plane of the sprite.
     |  
     |  change_y
     |      Get the velocity in the y plane of the sprite.
     |  
     |  collision_radius
     |      Get the collision radius.
     |      
     |      .. note:: Final collision checking is done via geometry that was
     |          set in get_points/set_points. These points are used in the
     |          check_for_collision function. This collision_radius variable
     |          is used as a "pre-check." We do a super-fast check with
     |          collision_radius and see if the sprites are close. If they are,
     |          then we look at the geometry and figure if they really are colliding.
     |  
     |  color
     |      Return the RGB color associated with the sprite.
     |  
     |  height
     |      Get the height in pixels of the sprite.
     |  
     |  hit_box
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  left
     |      Return the x coordinate of the left-side of the sprite's hit box.
     |  
     |  points
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  position
     |      Get the center x and y coordinates of the sprite.
     |      
     |      Returns:
     |          (center_x, center_y)
     |  
     |  radians
     |      Converts the degrees representation of self.angle into radians.
     |      :return: float
     |  
     |  right
     |      Return the x coordinate of the right-side of the sprite's hit box.
     |  
     |  scale
     |      Get the scale of the sprite.
     |  
     |  texture
     |  
     |  texture_transform
     |  
     |  top
     |      Return the y coordinate of the top of the sprite.
     |  
     |  width
     |      Get the width of the sprite.
    
    class AnimatedWalkingSprite(Sprite)
     |  AnimatedWalkingSprite(scale: float = 1, image_x: float = 0, image_y: float = 0, center_x: float = 0, center_y: float = 0)
     |  
     |  Sprite for platformer games that supports walking animations.
     |  Make sure to call update_animation after loading the animations so the
     |  initial texture can be set. Or manually set it.
     |  For a better example, see:
     |  http://arcade.academy/examples/platformer.html#animate-character
     |  
     |  Method resolution order:
     |      AnimatedWalkingSprite
     |      Sprite
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, scale: float = 1, image_x: float = 0, image_y: float = 0, center_x: float = 0, center_y: float = 0)
     |      Create a new sprite.
     |      
     |      :param str filename: Filename of an image that represents the sprite.
     |      :param float scale: Scale the image up or down. Scale of 1.0 is none.
     |      :param float image_x: X offset to sprite within sprite sheet.
     |      :param float image_y: Y offset to sprite within sprite sheet.
     |      :param float image_width: Width of the sprite
     |      :param float image_height: Height of the sprite
     |      :param float center_x: Location of the sprite
     |      :param float center_y: Location of the sprite
     |      :param bool flipped_horizontally: Mirror the sprite image. Flip left/right across vertical axis.
     |      :param bool flipped_vertically: Flip the image up/down across the horizontal axis.
     |      :param bool flipped_diagonally: Transpose the image, flip it across the diagonal.
     |      :param mirrored: Deprecated.
     |      :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.         Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,         :data:`PhysicsEnginePlatformer`         and 'Detailed' for the :data:`PymunkPhysicsEngine`.
     |      
     |          .. figure:: images/hit_box_algorithm_none.png
     |             :width: 40%
     |      
     |             hit_box_algorithm = "None"
     |      
     |          .. figure:: images/hit_box_algorithm_simple.png
     |             :width: 55%
     |      
     |             hit_box_algorithm = "Simple"
     |      
     |          .. figure:: images/hit_box_algorithm_detailed.png
     |             :width: 75%
     |      
     |             hit_box_algorithm = "Detailed"
     |      :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Logic for selecting the proper texture to use.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Sprite:
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  add_spatial_hashes(self)
     |      Add spatial hashes for this sprite in all the sprite lists it is part of.
     |  
     |  append_texture(self, texture: arcade.texture.Texture)
     |      Appends a new texture to the list of textures that can be
     |      applied to this sprite.
     |      
     |      :param arcade.Texture texture: Texture to add ot the list of available textures
     |  
     |  clear_spatial_hashes(self)
     |      Search the sprite lists this sprite is a part of, and remove it
     |      from any spatial hashes it is a part of.
     |  
     |  collides_with_list(self, sprite_list: 'SpriteList') -> list
     |      Check if current sprite is overlapping with any other sprite in a list
     |      
     |      Args:
     |          self: current Sprite
     |          sprite_list: SpriteList to check against
     |      
     |      Returns:
     |          SpriteList of all overlapping Sprites from the original SpriteList
     |  
     |  collides_with_point(self, point: Union[Tuple[float, float], List[float]]) -> bool
     |      Check if point is within the current sprite.
     |      
     |      Args:
     |          self: Current sprite
     |          point: Point to check.
     |      
     |      Returns:
     |          True if the point is contained within the sprite's boundary.
     |  
     |  collides_with_sprite(self, other: 'Sprite') -> bool
     |      Will check if a sprite is overlapping (colliding) another Sprite.
     |      
     |      Args:
     |          self: Current Sprite.
     |          other: The other sprite to check against.
     |      
     |      Returns:
     |          True or False, whether or not they are overlapping.
     |  
     |  draw(self)
     |      Draw the sprite.
     |  
     |  draw_hit_box(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0), line_thickness: float = 1)
     |      Draw a sprite's hit-box.
     |      
     |      The 'hit box' drawing is cached, so if you change the color/line thickness
     |      later, it won't take.
     |      
     |      :param color: Color of box
     |      :param line_thickness: How thick the box should be
     |  
     |  forward(self, speed: float = 1.0)
     |      Set a Sprite's position to speed by its angle
     |      :param speed: speed factor
     |  
     |  get_adjusted_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  get_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  get_points(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  kill(self)
     |      Alias of `remove_from_sprite_lists`
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pymunk_moved(self, physics_engine, dx, dy, d_angle)
     |      Called by the pymunk physics engine if this sprite moves.
     |  
     |  register_physics_engine(self, physics_engine)
     |      Called by the Pymunk physics engine when this sprite is added
     |      to that physics engine. Lets the sprite know about the engine and
     |      remove itself if it gets deleted.
     |  
     |  register_sprite_list(self, new_list)
     |      Register this sprite as belonging to a list. We will automatically
     |      remove ourselves from the the list when kill() is called.
     |  
     |  remove_from_sprite_lists(self)
     |      Remove the sprite from all sprite lists.
     |  
     |  rescale_relative_to_point(self, point: Union[Tuple[float, float], List[float]], factor: float) -> None
     |      Rescale the sprite relative to a different point than its center.
     |  
     |  reverse(self, speed: float = 1.0)
     |      Set a new speed, but in reverse.
     |      :param speed: speed factor
     |  
     |  set_hit_box(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hit box. Hit box should be relative to a sprite's center,
     |      and with a scale of 1.0.
     |      Points will be scaled with get_adjusted_hit_box.
     |  
     |  set_points(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hitbox
     |  
     |  set_position(self, center_x: float, center_y: float)
     |      Set a sprite's position
     |      
     |      :param float center_x: New x position of sprite
     |      :param float center_y: New y position of sprite
     |  
     |  set_texture(self, texture_no: int)
     |      Sets texture by texture id. Should be renamed because it takes
     |      a number rather than a texture, but keeping
     |      this for backwards compatibility.
     |  
     |  stop(self)
     |      Stop the Sprite's motion
     |  
     |  strafe(self, speed: float = 1.0)
     |      Set a sprites position perpendicular to its angle by speed
     |      :param speed: speed factor
     |  
     |  turn_left(self, theta: float = 90)
     |      Rotate the sprite left a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  turn_right(self, theta: float = 90)
     |      Rotate the sprite right a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  update(self)
     |      Update the sprite.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Sprite:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  alpha
     |      Return the alpha associated with the sprite.
     |  
     |  angle
     |      Get the angle of the sprite's rotation.
     |  
     |  bottom
     |      Return the y coordinate of the bottom of the sprite.
     |  
     |  center_x
     |      Get the center x coordinate of the sprite.
     |  
     |  center_y
     |      Get the center y coordinate of the sprite.
     |  
     |  change_x
     |      Get the velocity in the x plane of the sprite.
     |  
     |  change_y
     |      Get the velocity in the y plane of the sprite.
     |  
     |  collision_radius
     |      Get the collision radius.
     |      
     |      .. note:: Final collision checking is done via geometry that was
     |          set in get_points/set_points. These points are used in the
     |          check_for_collision function. This collision_radius variable
     |          is used as a "pre-check." We do a super-fast check with
     |          collision_radius and see if the sprites are close. If they are,
     |          then we look at the geometry and figure if they really are colliding.
     |  
     |  color
     |      Return the RGB color associated with the sprite.
     |  
     |  height
     |      Get the height in pixels of the sprite.
     |  
     |  hit_box
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  left
     |      Return the x coordinate of the left-side of the sprite's hit box.
     |  
     |  points
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  position
     |      Get the center x and y coordinates of the sprite.
     |      
     |      Returns:
     |          (center_x, center_y)
     |  
     |  radians
     |      Converts the degrees representation of self.angle into radians.
     |      :return: float
     |  
     |  right
     |      Return the x coordinate of the right-side of the sprite's hit box.
     |  
     |  scale
     |      Get the scale of the sprite.
     |  
     |  texture
     |  
     |  texture_transform
     |  
     |  top
     |      Return the y coordinate of the top of the sprite.
     |  
     |  width
     |      Get the width of the sprite.
    
    class AnimationKeyframe(builtins.object)
     |  AnimationKeyframe(tile_id: int, duration: int, texture: arcade.texture.Texture) -> None
     |  
     |  Used in animated sprites.
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |  
     |  __init__(self, tile_id: int, duration: int, texture: arcade.texture.Texture) -> None
     |  
     |  __repr__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'duration': <class 'int'>, 'texture': <class 'arcad...
     |  
     |  __dataclass_fields__ = {'duration': Field(name='duration',type=<class ...
     |  
     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...
     |  
     |  __hash__ = None
    
    class ArcadeContext(arcade.gl.context.Context)
     |  ArcadeContext(window: pyglet.window.win32.Win32Window)
     |  
     |  An OpenGL context implementation for Arcade with added custom features.
     |  This context is normally accessed thought :py:attr:`arcade.Window.ctx`.
     |  
     |  Pyglet users can use the base Context class and extend that as they please.
     |  
     |  **This is part of the low level rendering API in arcade
     |  and is mainly for more advanced usage**
     |  
     |  Method resolution order:
     |      ArcadeContext
     |      arcade.gl.context.Context
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, window: pyglet.window.win32.Win32Window)
     |      :param pyglet.window.Window window: The pyglet window
     |  
     |  load_program(self, *, vertex_shader: Union[str, pathlib.Path], fragment_shader: Union[str, pathlib.Path] = None, geometry_shader: Union[str, pathlib.Path] = None, defines: dict = None) -> arcade.gl.program.Program
     |      Create a new program given a file names that contain the vertex shader and
     |      fragment shader. Note that fragment and geometry shader are optional for
     |      when transform shaders are loaded.
     |      
     |      This method also supports the ``:resources:`` prefix.
     |      It's recommended to use absolute paths, but not required.
     |      
     |      Example::
     |      
     |          # The most common use case if having a vertex and fragment shader
     |          program = window.ctx.load_program(
     |              vertex_shader="vert.glsl",
     |              fragment_shader="frag.glsl",
     |          )
     |      
     |      :param Union[str,pathlib.Path] vertex_shader: path to vertex shader
     |      :param Union[str,pathlib.Path] fragment_shader: path to fragment shader (optional)
     |      :param Union[str,pathlib.Path] geometry_shader: path to geometry shader (optional)
     |      :param dict defines: Substitute ``#define`` values in the source
     |  
     |  load_texture(self, path: Union[str, pathlib.Path], *, flip: bool = True, build_mipmaps=False) -> arcade.gl.texture.Texture
     |      Loads and creates an OpenGL 2D texture.
     |      Currently all textures are converted to RGBA.
     |      
     |      Example::
     |      
     |          texture = window.ctx.load_texture("background.png")
     |      
     |      :param Union[str,pathlib.Path] path: Path to texture
     |      :param bool flip: Flips the image upside down
     |      :param bool build_mipmaps: Build mipmaps for the texture
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  projection_2d_matrix
     |      Get the current projection matrix as a numpy array.
     |      This 4x4 float32 matrix is calculated when setting :py:attr:`~arcade.ArcadeContext.projection_2d`.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  projection_2d
     |      Get or set the global orthogonal projection for arcade.
     |      
     |      This projection is used by sprites and shapes and is represented
     |      by four floats: ``(left, right, bottom, top)``
     |      
     |      :type: Tuple[float, float, float, float]
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from arcade.gl.context.Context:
     |  
     |  buffer(self, *, data: Union[Any, NoneType] = None, reserve: int = 0, usage: str = 'static') -> arcade.gl.buffer.Buffer
     |      Create a new OpenGL Buffer object.
     |      
     |      :param Any data: The buffer data, This can be ``bytes`` or an object supporting the buffer protocol.
     |      :param int reserve: The number of bytes reserve
     |      :param str usage: Buffer usage. 'static', 'dynamic' or 'stream'
     |      :rtype: :py:class:`~arcade.gl.Buffer`
     |  
     |  depth_texture(self, size: Tuple[int, int], *, data=None) -> arcade.gl.texture.Texture
     |      Create a 2D depth texture
     |      
     |      :param Tuple[int, int] size: The size of the texture
     |      :param Any data: The texture data (optional). Can be bytes or an object supporting the buffer protocol.
     |  
     |  disable(self, *args)
     |      Disable one or more context flags::
     |      
     |          # Single flag
     |          ctx.disable(ctx.BLEND)
     |          # Multiple flags
     |          ctx.disable(ctx.DEPTH_TEST, ctx.CULL_FACE)
     |  
     |  enable(self, *args)
     |      Enables one or more context flags::
     |      
     |          # Single flag
     |          ctx.enable(ctx.BLEND)
     |          # Multiple flags
     |          ctx.enable(ctx.DEPTH_TEST, ctx.CULL_FACE)
     |  
     |  enable_only(self, *args)
     |      Enable only some flags. This will disable all other flags.
     |      This is a simple way to ensure that context flag states
     |      are not lingering from other sections of your code base::
     |      
     |          # Ensure all flags are disabled (enable no flags)
     |          ctx.enable_only()
     |          # Make sure only blending is enabled
     |          ctx.enable_only(ctx.BLEND)
     |          # Make sure only depth test and culling is enabled
     |          ctx.enable_only(ctx.DEPTH_TEST, ctx.CULL_FACE)
     |  
     |  finish(self) -> None
     |      Wait until all OpenGL rendering commands are completed
     |  
     |  framebuffer(self, *, color_attachments: Union[arcade.gl.texture.Texture, List[arcade.gl.texture.Texture]] = None, depth_attachment: arcade.gl.texture.Texture = None) -> arcade.gl.framebuffer.Framebuffer
     |      Create a Framebuffer.
     |      
     |      :param List[arcade.gl.Texture] color_attachments: List of textures we want to render into
     |      :param arcade.gl.Texture depth_attachment: Depth texture
     |      :rtype: :py:class:`~arcade.gl.Framebuffer`
     |  
     |  geometry(self, content: Union[Sequence[arcade.gl.types.BufferDescription], NoneType] = None, index_buffer: arcade.gl.buffer.Buffer = None, mode: int = None)
     |      Create a Geomtry instance.
     |      
     |      :param list content: List of :py:class:`~arcade.gl.BufferDescription` (optional)
     |      :param Buffer index_buffer: Index/element buffer (optional)
     |      :param int mode: The default draw mode (optional)
     |  
     |  is_enabled(self, flag) -> bool
     |      Check if a context flag is enabled
     |      
     |      :type: bool
     |  
     |  program(self, *, vertex_shader: str, fragment_shader: str = None, geometry_shader: str = None, defines: Dict[str, str] = None) -> arcade.gl.program.Program
     |      Create a :py:class:`~arcade.gl.Program` given the vertex, fragment and geometry shader.
     |      
     |      :param str vertex_shader: vertex shader source
     |      :param str fragment_shader: fragment shader source (optional)
     |      :param str geometry_shader: geometry shader source (optional)
     |      :param dict defines: Substitute #defines values in the source (optional)
     |      :rtype: :py:class:`~arcade.gl.Program`
     |  
     |  query(self)
     |      Create a query object for measuring rendering calls in opengl.
     |      
     |      :rtype: :py:class:`~arcade.gl.Query`
     |  
     |  texture(self, size: Tuple[int, int], *, components: int = 4, dtype: str = 'f1', data: Any = None, wrap_x: ctypes.c_ulong = None, wrap_y: ctypes.c_ulong = None, filter: Tuple[ctypes.c_ulong, ctypes.c_ulong] = None) -> arcade.gl.texture.Texture
     |      Create a 2D Texture.
     |      
     |      Wrap modes: ``GL_REPEAT``, ``GL_MIRRORED_REPEAT``, ``GL_CLAMP_TO_EDGE``, ``GL_CLAMP_TO_BORDER``
     |      
     |      Minifying filters: ``GL_NEAREST``, ``GL_LINEAR``, ``GL_NEAREST_MIPMAP_NEAREST``, ``GL_LINEAR_MIPMAP_NEAREST``
     |      ``GL_NEAREST_MIPMAP_LINEAR``, ``GL_LINEAR_MIPMAP_LINEAR``
     |      
     |      Magnifying filters: ``GL_NEAREST``, ``GL_LINEAR``
     |      
     |      :param Tuple[int, int] size: The size of the texture
     |      :param int components: Number of components (1: R, 2: RG, 3: RGB, 4: RGBA)
     |      :param str dtype: The data type of each component: f1, f2, f4 / i1, i2, i4 / u1, u2, u4
     |      :param Any data: The texture data (optional). Can be bytes or an object supporting the buffer protocol.
     |      :param GLenum wrap_x: How the texture wraps in x direction
     |      :param GLenum wrap_y: How the texture wraps in y direction
     |      :param Tuple[GLenum,GLenum] filter: Minification and magnification filter
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from arcade.gl.context.Context:
     |  
     |  activate(ctx: 'Context') from builtins.type
     |      Mark a context as the currently active one
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from arcade.gl.context.Context:
     |  
     |  error
     |      Check OpenGL error
     |      
     |      Returns a string representation of the occurring error
     |      or ``None`` of no errors has occurred.
     |      
     |      Example::
     |      
     |          err = ctx.error
     |          if err:
     |              raise RuntimeError("OpenGL error: {err}")
     |      
     |      :type: str
     |  
     |  fbo
     |      Get the currently active framebuffer.
     |      This property is read-only
     |      
     |      :type: :py:class:`arcade.gl.Framebuffer`
     |  
     |  gl_version
     |      The OpenGL version as a 2 component tuple
     |      
     |      :type: tuple (major, minor) version
     |  
     |  screen
     |      The framebuffer for the window.
     |      
     |      :type: :py:class:`~arcade.Framebuffer`
     |  
     |  window
     |      The window this context belongs to.
     |      
     |      :type: ``pyglet.Window``
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from arcade.gl.context.Context:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  blend_func
     |      Get or the blend function::
     |      
     |          ctx.blend_func = ctx.ONE, ctx.ONE
     |      
     |      :type: tuple (src, dst)
     |  
     |  point_size
     |      float: Get or set the point size.
     |  
     |  primitive_restart_index
     |      Get or set the primitive restart index. Default is -1
     |  
     |  viewport
     |      Get or set the viewport for the currently active framebuffer.
     |      The viewport simply describes what pixels of the screen
     |      OpenGL should render to. Normally it would be the size of
     |      the window's framebuffer::
     |      
     |          # 4:3 screen
     |          ctx.viewport = 0, 0, 800, 600
     |          # 1080p
     |          ctx.viewport = 0, 0, 1920, 1080
     |          # Using the current framebuffer size
     |          ctx.viewport = 0, 0, *ctx.screen.size
     |      
     |      :type: tuple (x, y, width, height)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from arcade.gl.context.Context:
     |  
     |  BLEND = 3042
     |  
     |  BLEND_ADDITIVE = (1, 1)
     |  
     |  BLEND_DEFAULT = (770, 771)
     |  
     |  BLEND_PREMULTIPLIED_ALPHA = (770, 1)
     |  
     |  CLAMP_TO_BORDER = 33069
     |  
     |  CLAMP_TO_EDGE = 33071
     |  
     |  CULL_FACE = 2884
     |  
     |  DEPTH_TEST = 2929
     |  
     |  DST_ALPHA = 772
     |  
     |  DST_COLOR = 774
     |  
     |  FUNC_ADD = 32774
     |  
     |  FUNC_REVERSE_SUBTRACT = 32779
     |  
     |  FUNC_SUBTRACT = 32778
     |  
     |  LINEAR = 9729
     |  
     |  LINEAR_MIPMAP_LINEAR = 9987
     |  
     |  LINEAR_MIPMAP_NEAREST = 9985
     |  
     |  LINES = 1
     |  
     |  LINES_ADJACENCY = 10
     |  
     |  LINE_STRIP = 3
     |  
     |  LINE_STRIP_ADJACENCY = 11
     |  
     |  MAX = 32776
     |  
     |  MIN = 32775
     |  
     |  MIRRORED_REPEAT = 33648
     |  
     |  NEAREST = 9728
     |  
     |  NEAREST_MIPMAP_LINEAR = 9986
     |  
     |  NEAREST_MIPMAP_NEAREST = 9984
     |  
     |  ONE = 1
     |  
     |  ONE_MINUS_DST_ALPHA = 773
     |  
     |  ONE_MINUS_DST_COLOR = 775
     |  
     |  ONE_MINUS_SRC_ALPHA = 771
     |  
     |  ONE_MINUS_SRC_COLOR = 769
     |  
     |  POINTS = 0
     |  
     |  PROGRAM_POINT_SIZE = 34370
     |  
     |  REPEAT = 10497
     |  
     |  SRC_ALPHA = 770
     |  
     |  SRC_COLOR = 768
     |  
     |  TRIANGLES = 4
     |  
     |  TRIANGLES_ADJACENCY = 12
     |  
     |  TRIANGLE_FAN = 6
     |  
     |  TRIANGLE_STRIP = 5
     |  
     |  TRIANGLE_STRIP_ADJACENCY = 13
     |  
     |  ZERO = 0
     |  
     |  __annotations__ = {'active': typing.Union[ForwardRef('Context'), NoneT...
     |  
     |  active = None
    
    class CreateText(builtins.object)
     |  CreateText(text: str, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], font_size: float = 12, width: int = 20, align='left', font_name=('Calibri', 'Arial'), bold: bool = False, italic: bool = False, anchor_x='left', anchor_y='baseline', rotation=0)
     |  
     |  Class used for managing text
     |  
     |  Methods defined here:
     |  
     |  __init__(self, text: str, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], font_size: float = 12, width: int = 20, align='left', font_name=('Calibri', 'Arial'), bold: bool = False, italic: bool = False, anchor_x='left', anchor_y='baseline', rotation=0)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class EmitBurst(EmitController)
     |  EmitBurst(count: int)
     |  
     |  Used to configure an Emitter to emit particles in one burst
     |  
     |  Method resolution order:
     |      EmitBurst
     |      EmitController
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, count: int)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  how_many(self, delta_time: float, current_particle_count: int) -> int
     |  
     |  is_complete(self) -> bool
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from EmitController:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class EmitController(builtins.object)
     |  Base class for how a client configure the rate at which an Emitter emits Particles
     |  
     |  Subclasses allow the client to control the rate and duration of emitting
     |  
     |  Methods defined here:
     |  
     |  how_many(self, delta_time: float, current_particle_count: int) -> int
     |  
     |  is_complete(self) -> bool
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class EmitInterval(EmitController)
     |  EmitInterval(emit_interval: float)
     |  
     |  Base class used to configure an Emitter to have a constant rate of emitting. Will emit indefinitely.
     |  
     |  Method resolution order:
     |      EmitInterval
     |      EmitController
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, emit_interval: float)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  how_many(self, delta_time: float, current_particle_count: int) -> int
     |  
     |  is_complete(self) -> bool
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from EmitController:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class EmitMaintainCount(EmitController)
     |  EmitMaintainCount(particle_count: int)
     |  
     |  Used to configure an Emitter so it emits particles so that the given count is always maintained
     |  
     |  Method resolution order:
     |      EmitMaintainCount
     |      EmitController
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, particle_count: int)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  how_many(self, delta_time: float, current_particle_count: int) -> int
     |  
     |  is_complete(self) -> bool
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from EmitController:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Emitter(builtins.object)
     |  Emitter(center_xy: Union[Tuple[float, float], List[float]], emit_controller: arcade.emitter.EmitController, particle_factory: Callable[[ForwardRef('Emitter')], arcade.particle.Particle], change_xy: Union[Tuple[float, float], List[float]] = (0.0, 0.0), emit_done_cb: Callable[[ForwardRef('Emitter')], NoneType] = None, reap_cb: Callable[[], NoneType] = None)
     |  
     |  Emits and manages Particles over their lifetime.  The foundational class in a particle system.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, center_xy: Union[Tuple[float, float], List[float]], emit_controller: arcade.emitter.EmitController, particle_factory: Callable[[ForwardRef('Emitter')], arcade.particle.Particle], change_xy: Union[Tuple[float, float], List[float]] = (0.0, 0.0), emit_done_cb: Callable[[ForwardRef('Emitter')], NoneType] = None, reap_cb: Callable[[], NoneType] = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  can_reap(self)
     |      Determine if Emitter can be deleted
     |  
     |  draw(self)
     |  
     |  get_count(self)
     |  
     |  get_pos(self) -> Union[Tuple[float, float], List[float]]
     |      Get position of emitter
     |  
     |  update(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class EmitterIntervalWithCount(EmitInterval)
     |  EmitterIntervalWithCount(emit_interval: float, particle_count: int)
     |  
     |  Configure an Emitter to emit particles with given interval, ending after emitting given number of particles
     |  
     |  Method resolution order:
     |      EmitterIntervalWithCount
     |      EmitInterval
     |      EmitController
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, emit_interval: float, particle_count: int)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  how_many(self, delta_time: float, current_particle_count: int) -> int
     |  
     |  is_complete(self) -> bool
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from EmitController:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class EmitterIntervalWithTime(EmitInterval)
     |  EmitterIntervalWithTime(emit_interval: float, lifetime: float)
     |  
     |  Configure an Emitter to emit particles with given interval, ending after given number of seconds
     |  
     |  Method resolution order:
     |      EmitterIntervalWithTime
     |      EmitInterval
     |      EmitController
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, emit_interval: float, lifetime: float)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  how_many(self, delta_time: float, current_particle_count: int) -> int
     |  
     |  is_complete(self) -> bool
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from EmitController:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class EternalParticle(Particle)
     |  EternalParticle(filename_or_texture: Union[str, arcade.texture.Texture], change_xy: Union[Tuple[float, float], List[float]], center_xy: Union[Tuple[float, float], List[float]] = (0.0, 0.0), angle: float = 0, change_angle: float = 0, scale: float = 1.0, alpha: int = 255, mutation_callback=None)
     |  
     |  Particle that has no end to its life
     |  
     |  Method resolution order:
     |      EternalParticle
     |      Particle
     |      arcade.sprite.Sprite
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, filename_or_texture: Union[str, arcade.texture.Texture], change_xy: Union[Tuple[float, float], List[float]], center_xy: Union[Tuple[float, float], List[float]] = (0.0, 0.0), angle: float = 0, change_angle: float = 0, scale: float = 1.0, alpha: int = 255, mutation_callback=None)
     |      Create a new sprite.
     |      
     |      :param str filename: Filename of an image that represents the sprite.
     |      :param float scale: Scale the image up or down. Scale of 1.0 is none.
     |      :param float image_x: X offset to sprite within sprite sheet.
     |      :param float image_y: Y offset to sprite within sprite sheet.
     |      :param float image_width: Width of the sprite
     |      :param float image_height: Height of the sprite
     |      :param float center_x: Location of the sprite
     |      :param float center_y: Location of the sprite
     |      :param bool flipped_horizontally: Mirror the sprite image. Flip left/right across vertical axis.
     |      :param bool flipped_vertically: Flip the image up/down across the horizontal axis.
     |      :param bool flipped_diagonally: Transpose the image, flip it across the diagonal.
     |      :param mirrored: Deprecated.
     |      :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.         Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,         :data:`PhysicsEnginePlatformer`         and 'Detailed' for the :data:`PymunkPhysicsEngine`.
     |      
     |          .. figure:: images/hit_box_algorithm_none.png
     |             :width: 40%
     |      
     |             hit_box_algorithm = "None"
     |      
     |          .. figure:: images/hit_box_algorithm_simple.png
     |             :width: 55%
     |      
     |             hit_box_algorithm = "Simple"
     |      
     |          .. figure:: images/hit_box_algorithm_detailed.png
     |             :width: 75%
     |      
     |             hit_box_algorithm = "Detailed"
     |      :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
     |  
     |  can_reap(self)
     |      Determine if Particle can be deleted
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Particle:
     |  
     |  update(self)
     |      Advance the Particle's simulation
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from arcade.sprite.Sprite:
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  add_spatial_hashes(self)
     |      Add spatial hashes for this sprite in all the sprite lists it is part of.
     |  
     |  append_texture(self, texture: arcade.texture.Texture)
     |      Appends a new texture to the list of textures that can be
     |      applied to this sprite.
     |      
     |      :param arcade.Texture texture: Texture to add ot the list of available textures
     |  
     |  clear_spatial_hashes(self)
     |      Search the sprite lists this sprite is a part of, and remove it
     |      from any spatial hashes it is a part of.
     |  
     |  collides_with_list(self, sprite_list: 'SpriteList') -> list
     |      Check if current sprite is overlapping with any other sprite in a list
     |      
     |      Args:
     |          self: current Sprite
     |          sprite_list: SpriteList to check against
     |      
     |      Returns:
     |          SpriteList of all overlapping Sprites from the original SpriteList
     |  
     |  collides_with_point(self, point: Union[Tuple[float, float], List[float]]) -> bool
     |      Check if point is within the current sprite.
     |      
     |      Args:
     |          self: Current sprite
     |          point: Point to check.
     |      
     |      Returns:
     |          True if the point is contained within the sprite's boundary.
     |  
     |  collides_with_sprite(self, other: 'Sprite') -> bool
     |      Will check if a sprite is overlapping (colliding) another Sprite.
     |      
     |      Args:
     |          self: Current Sprite.
     |          other: The other sprite to check against.
     |      
     |      Returns:
     |          True or False, whether or not they are overlapping.
     |  
     |  draw(self)
     |      Draw the sprite.
     |  
     |  draw_hit_box(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0), line_thickness: float = 1)
     |      Draw a sprite's hit-box.
     |      
     |      The 'hit box' drawing is cached, so if you change the color/line thickness
     |      later, it won't take.
     |      
     |      :param color: Color of box
     |      :param line_thickness: How thick the box should be
     |  
     |  forward(self, speed: float = 1.0)
     |      Set a Sprite's position to speed by its angle
     |      :param speed: speed factor
     |  
     |  get_adjusted_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  get_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  get_points(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  kill(self)
     |      Alias of `remove_from_sprite_lists`
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pymunk_moved(self, physics_engine, dx, dy, d_angle)
     |      Called by the pymunk physics engine if this sprite moves.
     |  
     |  register_physics_engine(self, physics_engine)
     |      Called by the Pymunk physics engine when this sprite is added
     |      to that physics engine. Lets the sprite know about the engine and
     |      remove itself if it gets deleted.
     |  
     |  register_sprite_list(self, new_list)
     |      Register this sprite as belonging to a list. We will automatically
     |      remove ourselves from the the list when kill() is called.
     |  
     |  remove_from_sprite_lists(self)
     |      Remove the sprite from all sprite lists.
     |  
     |  rescale_relative_to_point(self, point: Union[Tuple[float, float], List[float]], factor: float) -> None
     |      Rescale the sprite relative to a different point than its center.
     |  
     |  reverse(self, speed: float = 1.0)
     |      Set a new speed, but in reverse.
     |      :param speed: speed factor
     |  
     |  set_hit_box(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hit box. Hit box should be relative to a sprite's center,
     |      and with a scale of 1.0.
     |      Points will be scaled with get_adjusted_hit_box.
     |  
     |  set_points(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hitbox
     |  
     |  set_position(self, center_x: float, center_y: float)
     |      Set a sprite's position
     |      
     |      :param float center_x: New x position of sprite
     |      :param float center_y: New y position of sprite
     |  
     |  set_texture(self, texture_no: int)
     |      Sets texture by texture id. Should be renamed because it takes
     |      a number rather than a texture, but keeping
     |      this for backwards compatibility.
     |  
     |  stop(self)
     |      Stop the Sprite's motion
     |  
     |  strafe(self, speed: float = 1.0)
     |      Set a sprites position perpendicular to its angle by speed
     |      :param speed: speed factor
     |  
     |  turn_left(self, theta: float = 90)
     |      Rotate the sprite left a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  turn_right(self, theta: float = 90)
     |      Rotate the sprite right a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Override this to add code that will change
     |      what image is shown, so the sprite can be
     |      animated.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from arcade.sprite.Sprite:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  alpha
     |      Return the alpha associated with the sprite.
     |  
     |  angle
     |      Get the angle of the sprite's rotation.
     |  
     |  bottom
     |      Return the y coordinate of the bottom of the sprite.
     |  
     |  center_x
     |      Get the center x coordinate of the sprite.
     |  
     |  center_y
     |      Get the center y coordinate of the sprite.
     |  
     |  change_x
     |      Get the velocity in the x plane of the sprite.
     |  
     |  change_y
     |      Get the velocity in the y plane of the sprite.
     |  
     |  collision_radius
     |      Get the collision radius.
     |      
     |      .. note:: Final collision checking is done via geometry that was
     |          set in get_points/set_points. These points are used in the
     |          check_for_collision function. This collision_radius variable
     |          is used as a "pre-check." We do a super-fast check with
     |          collision_radius and see if the sprites are close. If they are,
     |          then we look at the geometry and figure if they really are colliding.
     |  
     |  color
     |      Return the RGB color associated with the sprite.
     |  
     |  height
     |      Get the height in pixels of the sprite.
     |  
     |  hit_box
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  left
     |      Return the x coordinate of the left-side of the sprite's hit box.
     |  
     |  points
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  position
     |      Get the center x and y coordinates of the sprite.
     |      
     |      Returns:
     |          (center_x, center_y)
     |  
     |  radians
     |      Converts the degrees representation of self.angle into radians.
     |      :return: float
     |  
     |  right
     |      Return the x coordinate of the right-side of the sprite's hit box.
     |  
     |  scale
     |      Get the scale of the sprite.
     |  
     |  texture
     |  
     |  texture_transform
     |  
     |  top
     |      Return the y coordinate of the top of the sprite.
     |  
     |  width
     |      Get the width of the sprite.
    
    class FadeParticle(LifetimeParticle)
     |  FadeParticle(filename_or_texture: Union[str, arcade.texture.Texture], change_xy: Union[Tuple[float, float], List[float]], lifetime: float, center_xy: Union[Tuple[float, float], List[float]] = (0.0, 0.0), angle: float = 0, change_angle: float = 0, scale: float = 1.0, start_alpha: int = 255, end_alpha: int = 0, mutation_callback=None)
     |  
     |  Particle that animates its alpha between two values during its lifetime
     |  
     |  Method resolution order:
     |      FadeParticle
     |      LifetimeParticle
     |      Particle
     |      arcade.sprite.Sprite
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, filename_or_texture: Union[str, arcade.texture.Texture], change_xy: Union[Tuple[float, float], List[float]], lifetime: float, center_xy: Union[Tuple[float, float], List[float]] = (0.0, 0.0), angle: float = 0, change_angle: float = 0, scale: float = 1.0, start_alpha: int = 255, end_alpha: int = 0, mutation_callback=None)
     |      Create a new sprite.
     |      
     |      :param str filename: Filename of an image that represents the sprite.
     |      :param float scale: Scale the image up or down. Scale of 1.0 is none.
     |      :param float image_x: X offset to sprite within sprite sheet.
     |      :param float image_y: Y offset to sprite within sprite sheet.
     |      :param float image_width: Width of the sprite
     |      :param float image_height: Height of the sprite
     |      :param float center_x: Location of the sprite
     |      :param float center_y: Location of the sprite
     |      :param bool flipped_horizontally: Mirror the sprite image. Flip left/right across vertical axis.
     |      :param bool flipped_vertically: Flip the image up/down across the horizontal axis.
     |      :param bool flipped_diagonally: Transpose the image, flip it across the diagonal.
     |      :param mirrored: Deprecated.
     |      :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.         Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,         :data:`PhysicsEnginePlatformer`         and 'Detailed' for the :data:`PymunkPhysicsEngine`.
     |      
     |          .. figure:: images/hit_box_algorithm_none.png
     |             :width: 40%
     |      
     |             hit_box_algorithm = "None"
     |      
     |          .. figure:: images/hit_box_algorithm_simple.png
     |             :width: 55%
     |      
     |             hit_box_algorithm = "Simple"
     |      
     |          .. figure:: images/hit_box_algorithm_detailed.png
     |             :width: 75%
     |      
     |             hit_box_algorithm = "Detailed"
     |      :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
     |  
     |  update(self)
     |      Advance the Particle's simulation
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LifetimeParticle:
     |  
     |  can_reap(self)
     |      Determine if Particle can be deleted
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from arcade.sprite.Sprite:
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  add_spatial_hashes(self)
     |      Add spatial hashes for this sprite in all the sprite lists it is part of.
     |  
     |  append_texture(self, texture: arcade.texture.Texture)
     |      Appends a new texture to the list of textures that can be
     |      applied to this sprite.
     |      
     |      :param arcade.Texture texture: Texture to add ot the list of available textures
     |  
     |  clear_spatial_hashes(self)
     |      Search the sprite lists this sprite is a part of, and remove it
     |      from any spatial hashes it is a part of.
     |  
     |  collides_with_list(self, sprite_list: 'SpriteList') -> list
     |      Check if current sprite is overlapping with any other sprite in a list
     |      
     |      Args:
     |          self: current Sprite
     |          sprite_list: SpriteList to check against
     |      
     |      Returns:
     |          SpriteList of all overlapping Sprites from the original SpriteList
     |  
     |  collides_with_point(self, point: Union[Tuple[float, float], List[float]]) -> bool
     |      Check if point is within the current sprite.
     |      
     |      Args:
     |          self: Current sprite
     |          point: Point to check.
     |      
     |      Returns:
     |          True if the point is contained within the sprite's boundary.
     |  
     |  collides_with_sprite(self, other: 'Sprite') -> bool
     |      Will check if a sprite is overlapping (colliding) another Sprite.
     |      
     |      Args:
     |          self: Current Sprite.
     |          other: The other sprite to check against.
     |      
     |      Returns:
     |          True or False, whether or not they are overlapping.
     |  
     |  draw(self)
     |      Draw the sprite.
     |  
     |  draw_hit_box(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0), line_thickness: float = 1)
     |      Draw a sprite's hit-box.
     |      
     |      The 'hit box' drawing is cached, so if you change the color/line thickness
     |      later, it won't take.
     |      
     |      :param color: Color of box
     |      :param line_thickness: How thick the box should be
     |  
     |  forward(self, speed: float = 1.0)
     |      Set a Sprite's position to speed by its angle
     |      :param speed: speed factor
     |  
     |  get_adjusted_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  get_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  get_points(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  kill(self)
     |      Alias of `remove_from_sprite_lists`
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pymunk_moved(self, physics_engine, dx, dy, d_angle)
     |      Called by the pymunk physics engine if this sprite moves.
     |  
     |  register_physics_engine(self, physics_engine)
     |      Called by the Pymunk physics engine when this sprite is added
     |      to that physics engine. Lets the sprite know about the engine and
     |      remove itself if it gets deleted.
     |  
     |  register_sprite_list(self, new_list)
     |      Register this sprite as belonging to a list. We will automatically
     |      remove ourselves from the the list when kill() is called.
     |  
     |  remove_from_sprite_lists(self)
     |      Remove the sprite from all sprite lists.
     |  
     |  rescale_relative_to_point(self, point: Union[Tuple[float, float], List[float]], factor: float) -> None
     |      Rescale the sprite relative to a different point than its center.
     |  
     |  reverse(self, speed: float = 1.0)
     |      Set a new speed, but in reverse.
     |      :param speed: speed factor
     |  
     |  set_hit_box(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hit box. Hit box should be relative to a sprite's center,
     |      and with a scale of 1.0.
     |      Points will be scaled with get_adjusted_hit_box.
     |  
     |  set_points(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hitbox
     |  
     |  set_position(self, center_x: float, center_y: float)
     |      Set a sprite's position
     |      
     |      :param float center_x: New x position of sprite
     |      :param float center_y: New y position of sprite
     |  
     |  set_texture(self, texture_no: int)
     |      Sets texture by texture id. Should be renamed because it takes
     |      a number rather than a texture, but keeping
     |      this for backwards compatibility.
     |  
     |  stop(self)
     |      Stop the Sprite's motion
     |  
     |  strafe(self, speed: float = 1.0)
     |      Set a sprites position perpendicular to its angle by speed
     |      :param speed: speed factor
     |  
     |  turn_left(self, theta: float = 90)
     |      Rotate the sprite left a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  turn_right(self, theta: float = 90)
     |      Rotate the sprite right a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Override this to add code that will change
     |      what image is shown, so the sprite can be
     |      animated.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from arcade.sprite.Sprite:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  alpha
     |      Return the alpha associated with the sprite.
     |  
     |  angle
     |      Get the angle of the sprite's rotation.
     |  
     |  bottom
     |      Return the y coordinate of the bottom of the sprite.
     |  
     |  center_x
     |      Get the center x coordinate of the sprite.
     |  
     |  center_y
     |      Get the center y coordinate of the sprite.
     |  
     |  change_x
     |      Get the velocity in the x plane of the sprite.
     |  
     |  change_y
     |      Get the velocity in the y plane of the sprite.
     |  
     |  collision_radius
     |      Get the collision radius.
     |      
     |      .. note:: Final collision checking is done via geometry that was
     |          set in get_points/set_points. These points are used in the
     |          check_for_collision function. This collision_radius variable
     |          is used as a "pre-check." We do a super-fast check with
     |          collision_radius and see if the sprites are close. If they are,
     |          then we look at the geometry and figure if they really are colliding.
     |  
     |  color
     |      Return the RGB color associated with the sprite.
     |  
     |  height
     |      Get the height in pixels of the sprite.
     |  
     |  hit_box
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  left
     |      Return the x coordinate of the left-side of the sprite's hit box.
     |  
     |  points
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  position
     |      Get the center x and y coordinates of the sprite.
     |      
     |      Returns:
     |          (center_x, center_y)
     |  
     |  radians
     |      Converts the degrees representation of self.angle into radians.
     |      :return: float
     |  
     |  right
     |      Return the x coordinate of the right-side of the sprite's hit box.
     |  
     |  scale
     |      Get the scale of the sprite.
     |  
     |  texture
     |  
     |  texture_transform
     |  
     |  top
     |      Return the y coordinate of the top of the sprite.
     |  
     |  width
     |      Get the width of the sprite.
    
    class LifetimeParticle(Particle)
     |  LifetimeParticle(filename_or_texture: Union[str, arcade.texture.Texture], change_xy: Union[Tuple[float, float], List[float]], lifetime: float, center_xy: Union[Tuple[float, float], List[float]] = (0.0, 0.0), angle: float = 0, change_angle: float = 0, scale: float = 1.0, alpha: int = 255, mutation_callback=None)
     |  
     |  Particle that lives for a given amount of time and is then deleted
     |  
     |  Method resolution order:
     |      LifetimeParticle
     |      Particle
     |      arcade.sprite.Sprite
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, filename_or_texture: Union[str, arcade.texture.Texture], change_xy: Union[Tuple[float, float], List[float]], lifetime: float, center_xy: Union[Tuple[float, float], List[float]] = (0.0, 0.0), angle: float = 0, change_angle: float = 0, scale: float = 1.0, alpha: int = 255, mutation_callback=None)
     |      Create a new sprite.
     |      
     |      :param str filename: Filename of an image that represents the sprite.
     |      :param float scale: Scale the image up or down. Scale of 1.0 is none.
     |      :param float image_x: X offset to sprite within sprite sheet.
     |      :param float image_y: Y offset to sprite within sprite sheet.
     |      :param float image_width: Width of the sprite
     |      :param float image_height: Height of the sprite
     |      :param float center_x: Location of the sprite
     |      :param float center_y: Location of the sprite
     |      :param bool flipped_horizontally: Mirror the sprite image. Flip left/right across vertical axis.
     |      :param bool flipped_vertically: Flip the image up/down across the horizontal axis.
     |      :param bool flipped_diagonally: Transpose the image, flip it across the diagonal.
     |      :param mirrored: Deprecated.
     |      :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.         Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,         :data:`PhysicsEnginePlatformer`         and 'Detailed' for the :data:`PymunkPhysicsEngine`.
     |      
     |          .. figure:: images/hit_box_algorithm_none.png
     |             :width: 40%
     |      
     |             hit_box_algorithm = "None"
     |      
     |          .. figure:: images/hit_box_algorithm_simple.png
     |             :width: 55%
     |      
     |             hit_box_algorithm = "Simple"
     |      
     |          .. figure:: images/hit_box_algorithm_detailed.png
     |             :width: 75%
     |      
     |             hit_box_algorithm = "Detailed"
     |      :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
     |  
     |  can_reap(self)
     |      Determine if Particle can be deleted
     |  
     |  update(self)
     |      Advance the Particle's simulation
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from arcade.sprite.Sprite:
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  add_spatial_hashes(self)
     |      Add spatial hashes for this sprite in all the sprite lists it is part of.
     |  
     |  append_texture(self, texture: arcade.texture.Texture)
     |      Appends a new texture to the list of textures that can be
     |      applied to this sprite.
     |      
     |      :param arcade.Texture texture: Texture to add ot the list of available textures
     |  
     |  clear_spatial_hashes(self)
     |      Search the sprite lists this sprite is a part of, and remove it
     |      from any spatial hashes it is a part of.
     |  
     |  collides_with_list(self, sprite_list: 'SpriteList') -> list
     |      Check if current sprite is overlapping with any other sprite in a list
     |      
     |      Args:
     |          self: current Sprite
     |          sprite_list: SpriteList to check against
     |      
     |      Returns:
     |          SpriteList of all overlapping Sprites from the original SpriteList
     |  
     |  collides_with_point(self, point: Union[Tuple[float, float], List[float]]) -> bool
     |      Check if point is within the current sprite.
     |      
     |      Args:
     |          self: Current sprite
     |          point: Point to check.
     |      
     |      Returns:
     |          True if the point is contained within the sprite's boundary.
     |  
     |  collides_with_sprite(self, other: 'Sprite') -> bool
     |      Will check if a sprite is overlapping (colliding) another Sprite.
     |      
     |      Args:
     |          self: Current Sprite.
     |          other: The other sprite to check against.
     |      
     |      Returns:
     |          True or False, whether or not they are overlapping.
     |  
     |  draw(self)
     |      Draw the sprite.
     |  
     |  draw_hit_box(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0), line_thickness: float = 1)
     |      Draw a sprite's hit-box.
     |      
     |      The 'hit box' drawing is cached, so if you change the color/line thickness
     |      later, it won't take.
     |      
     |      :param color: Color of box
     |      :param line_thickness: How thick the box should be
     |  
     |  forward(self, speed: float = 1.0)
     |      Set a Sprite's position to speed by its angle
     |      :param speed: speed factor
     |  
     |  get_adjusted_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  get_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  get_points(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  kill(self)
     |      Alias of `remove_from_sprite_lists`
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pymunk_moved(self, physics_engine, dx, dy, d_angle)
     |      Called by the pymunk physics engine if this sprite moves.
     |  
     |  register_physics_engine(self, physics_engine)
     |      Called by the Pymunk physics engine when this sprite is added
     |      to that physics engine. Lets the sprite know about the engine and
     |      remove itself if it gets deleted.
     |  
     |  register_sprite_list(self, new_list)
     |      Register this sprite as belonging to a list. We will automatically
     |      remove ourselves from the the list when kill() is called.
     |  
     |  remove_from_sprite_lists(self)
     |      Remove the sprite from all sprite lists.
     |  
     |  rescale_relative_to_point(self, point: Union[Tuple[float, float], List[float]], factor: float) -> None
     |      Rescale the sprite relative to a different point than its center.
     |  
     |  reverse(self, speed: float = 1.0)
     |      Set a new speed, but in reverse.
     |      :param speed: speed factor
     |  
     |  set_hit_box(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hit box. Hit box should be relative to a sprite's center,
     |      and with a scale of 1.0.
     |      Points will be scaled with get_adjusted_hit_box.
     |  
     |  set_points(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hitbox
     |  
     |  set_position(self, center_x: float, center_y: float)
     |      Set a sprite's position
     |      
     |      :param float center_x: New x position of sprite
     |      :param float center_y: New y position of sprite
     |  
     |  set_texture(self, texture_no: int)
     |      Sets texture by texture id. Should be renamed because it takes
     |      a number rather than a texture, but keeping
     |      this for backwards compatibility.
     |  
     |  stop(self)
     |      Stop the Sprite's motion
     |  
     |  strafe(self, speed: float = 1.0)
     |      Set a sprites position perpendicular to its angle by speed
     |      :param speed: speed factor
     |  
     |  turn_left(self, theta: float = 90)
     |      Rotate the sprite left a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  turn_right(self, theta: float = 90)
     |      Rotate the sprite right a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Override this to add code that will change
     |      what image is shown, so the sprite can be
     |      animated.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from arcade.sprite.Sprite:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  alpha
     |      Return the alpha associated with the sprite.
     |  
     |  angle
     |      Get the angle of the sprite's rotation.
     |  
     |  bottom
     |      Return the y coordinate of the bottom of the sprite.
     |  
     |  center_x
     |      Get the center x coordinate of the sprite.
     |  
     |  center_y
     |      Get the center y coordinate of the sprite.
     |  
     |  change_x
     |      Get the velocity in the x plane of the sprite.
     |  
     |  change_y
     |      Get the velocity in the y plane of the sprite.
     |  
     |  collision_radius
     |      Get the collision radius.
     |      
     |      .. note:: Final collision checking is done via geometry that was
     |          set in get_points/set_points. These points are used in the
     |          check_for_collision function. This collision_radius variable
     |          is used as a "pre-check." We do a super-fast check with
     |          collision_radius and see if the sprites are close. If they are,
     |          then we look at the geometry and figure if they really are colliding.
     |  
     |  color
     |      Return the RGB color associated with the sprite.
     |  
     |  height
     |      Get the height in pixels of the sprite.
     |  
     |  hit_box
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  left
     |      Return the x coordinate of the left-side of the sprite's hit box.
     |  
     |  points
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  position
     |      Get the center x and y coordinates of the sprite.
     |      
     |      Returns:
     |          (center_x, center_y)
     |  
     |  radians
     |      Converts the degrees representation of self.angle into radians.
     |      :return: float
     |  
     |  right
     |      Return the x coordinate of the right-side of the sprite's hit box.
     |  
     |  scale
     |      Get the scale of the sprite.
     |  
     |  texture
     |  
     |  texture_transform
     |  
     |  top
     |      Return the y coordinate of the top of the sprite.
     |  
     |  width
     |      Get the width of the sprite.
    
    class Matrix3x3(builtins.object)
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  multiply(self, o: List[float])
     |  
     |  reset(self)
     |  
     |  rotate(self, phi: float)
     |  
     |  scale(self, sx: float, sy: float)
     |  
     |  shear(self, sx: float, sy: float)
     |  
     |  translate(self, tx: float, ty: float)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    NamedPoint = class Point(builtins.tuple)
     |  NamedPoint(x, y)
     |  
     |  Point(x, y)
     |  
     |  Method resolution order:
     |      Point
     |      builtins.tuple
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __getnewargs__(self)
     |      Return self as a plain tuple.  Used by copy and pickle.
     |  
     |  __repr__(self)
     |      Return a nicely formatted representation string
     |  
     |  _asdict(self)
     |      Return a new dict which maps field names to their values.
     |  
     |  _replace(self, /, **kwds)
     |      Return a new Point object replacing specified fields with new values
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  _make(iterable) from builtins.type
     |      Make a new Point object from a sequence or iterable
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(_cls, x, y)
     |      Create new instance of Point(x, y)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  x
     |      Alias for field number 0
     |  
     |  y
     |      Alias for field number 1
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  _field_defaults = {}
     |  
     |  _fields = ('x', 'y')
     |  
     |  _fields_defaults = {}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.tuple:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(self, key, /)
     |      Return self[key].
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  count(self, value, /)
     |      Return number of occurrences of value.
     |  
     |  index(self, value, start=0, stop=2147483647, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
    
    class NoOpenGLException(builtins.Exception)
     |  Exception when we can't get an OpenGL 3.3+ context
     |  
     |  Method resolution order:
     |      NoOpenGLException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class Particle(arcade.sprite.Sprite)
     |  Particle(filename_or_texture: Union[str, arcade.texture.Texture], change_xy: Union[Tuple[float, float], List[float]], center_xy: Union[Tuple[float, float], List[float]] = (0.0, 0.0), angle: float = 0.0, change_angle: float = 0.0, scale: float = 1.0, alpha: int = 255, mutation_callback=None)
     |  
     |  Sprite that is emitted from an Emitter
     |  
     |  Method resolution order:
     |      Particle
     |      arcade.sprite.Sprite
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, filename_or_texture: Union[str, arcade.texture.Texture], change_xy: Union[Tuple[float, float], List[float]], center_xy: Union[Tuple[float, float], List[float]] = (0.0, 0.0), angle: float = 0.0, change_angle: float = 0.0, scale: float = 1.0, alpha: int = 255, mutation_callback=None)
     |      Create a new sprite.
     |      
     |      :param str filename: Filename of an image that represents the sprite.
     |      :param float scale: Scale the image up or down. Scale of 1.0 is none.
     |      :param float image_x: X offset to sprite within sprite sheet.
     |      :param float image_y: Y offset to sprite within sprite sheet.
     |      :param float image_width: Width of the sprite
     |      :param float image_height: Height of the sprite
     |      :param float center_x: Location of the sprite
     |      :param float center_y: Location of the sprite
     |      :param bool flipped_horizontally: Mirror the sprite image. Flip left/right across vertical axis.
     |      :param bool flipped_vertically: Flip the image up/down across the horizontal axis.
     |      :param bool flipped_diagonally: Transpose the image, flip it across the diagonal.
     |      :param mirrored: Deprecated.
     |      :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.         Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,         :data:`PhysicsEnginePlatformer`         and 'Detailed' for the :data:`PymunkPhysicsEngine`.
     |      
     |          .. figure:: images/hit_box_algorithm_none.png
     |             :width: 40%
     |      
     |             hit_box_algorithm = "None"
     |      
     |          .. figure:: images/hit_box_algorithm_simple.png
     |             :width: 55%
     |      
     |             hit_box_algorithm = "Simple"
     |      
     |          .. figure:: images/hit_box_algorithm_detailed.png
     |             :width: 75%
     |      
     |             hit_box_algorithm = "Detailed"
     |      :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
     |  
     |  can_reap(self)
     |      Determine if Particle can be deleted
     |  
     |  update(self)
     |      Advance the Particle's simulation
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from arcade.sprite.Sprite:
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  add_spatial_hashes(self)
     |      Add spatial hashes for this sprite in all the sprite lists it is part of.
     |  
     |  append_texture(self, texture: arcade.texture.Texture)
     |      Appends a new texture to the list of textures that can be
     |      applied to this sprite.
     |      
     |      :param arcade.Texture texture: Texture to add ot the list of available textures
     |  
     |  clear_spatial_hashes(self)
     |      Search the sprite lists this sprite is a part of, and remove it
     |      from any spatial hashes it is a part of.
     |  
     |  collides_with_list(self, sprite_list: 'SpriteList') -> list
     |      Check if current sprite is overlapping with any other sprite in a list
     |      
     |      Args:
     |          self: current Sprite
     |          sprite_list: SpriteList to check against
     |      
     |      Returns:
     |          SpriteList of all overlapping Sprites from the original SpriteList
     |  
     |  collides_with_point(self, point: Union[Tuple[float, float], List[float]]) -> bool
     |      Check if point is within the current sprite.
     |      
     |      Args:
     |          self: Current sprite
     |          point: Point to check.
     |      
     |      Returns:
     |          True if the point is contained within the sprite's boundary.
     |  
     |  collides_with_sprite(self, other: 'Sprite') -> bool
     |      Will check if a sprite is overlapping (colliding) another Sprite.
     |      
     |      Args:
     |          self: Current Sprite.
     |          other: The other sprite to check against.
     |      
     |      Returns:
     |          True or False, whether or not they are overlapping.
     |  
     |  draw(self)
     |      Draw the sprite.
     |  
     |  draw_hit_box(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0), line_thickness: float = 1)
     |      Draw a sprite's hit-box.
     |      
     |      The 'hit box' drawing is cached, so if you change the color/line thickness
     |      later, it won't take.
     |      
     |      :param color: Color of box
     |      :param line_thickness: How thick the box should be
     |  
     |  forward(self, speed: float = 1.0)
     |      Set a Sprite's position to speed by its angle
     |      :param speed: speed factor
     |  
     |  get_adjusted_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  get_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  get_points(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  kill(self)
     |      Alias of `remove_from_sprite_lists`
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pymunk_moved(self, physics_engine, dx, dy, d_angle)
     |      Called by the pymunk physics engine if this sprite moves.
     |  
     |  register_physics_engine(self, physics_engine)
     |      Called by the Pymunk physics engine when this sprite is added
     |      to that physics engine. Lets the sprite know about the engine and
     |      remove itself if it gets deleted.
     |  
     |  register_sprite_list(self, new_list)
     |      Register this sprite as belonging to a list. We will automatically
     |      remove ourselves from the the list when kill() is called.
     |  
     |  remove_from_sprite_lists(self)
     |      Remove the sprite from all sprite lists.
     |  
     |  rescale_relative_to_point(self, point: Union[Tuple[float, float], List[float]], factor: float) -> None
     |      Rescale the sprite relative to a different point than its center.
     |  
     |  reverse(self, speed: float = 1.0)
     |      Set a new speed, but in reverse.
     |      :param speed: speed factor
     |  
     |  set_hit_box(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hit box. Hit box should be relative to a sprite's center,
     |      and with a scale of 1.0.
     |      Points will be scaled with get_adjusted_hit_box.
     |  
     |  set_points(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hitbox
     |  
     |  set_position(self, center_x: float, center_y: float)
     |      Set a sprite's position
     |      
     |      :param float center_x: New x position of sprite
     |      :param float center_y: New y position of sprite
     |  
     |  set_texture(self, texture_no: int)
     |      Sets texture by texture id. Should be renamed because it takes
     |      a number rather than a texture, but keeping
     |      this for backwards compatibility.
     |  
     |  stop(self)
     |      Stop the Sprite's motion
     |  
     |  strafe(self, speed: float = 1.0)
     |      Set a sprites position perpendicular to its angle by speed
     |      :param speed: speed factor
     |  
     |  turn_left(self, theta: float = 90)
     |      Rotate the sprite left a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  turn_right(self, theta: float = 90)
     |      Rotate the sprite right a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Override this to add code that will change
     |      what image is shown, so the sprite can be
     |      animated.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from arcade.sprite.Sprite:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  alpha
     |      Return the alpha associated with the sprite.
     |  
     |  angle
     |      Get the angle of the sprite's rotation.
     |  
     |  bottom
     |      Return the y coordinate of the bottom of the sprite.
     |  
     |  center_x
     |      Get the center x coordinate of the sprite.
     |  
     |  center_y
     |      Get the center y coordinate of the sprite.
     |  
     |  change_x
     |      Get the velocity in the x plane of the sprite.
     |  
     |  change_y
     |      Get the velocity in the y plane of the sprite.
     |  
     |  collision_radius
     |      Get the collision radius.
     |      
     |      .. note:: Final collision checking is done via geometry that was
     |          set in get_points/set_points. These points are used in the
     |          check_for_collision function. This collision_radius variable
     |          is used as a "pre-check." We do a super-fast check with
     |          collision_radius and see if the sprites are close. If they are,
     |          then we look at the geometry and figure if they really are colliding.
     |  
     |  color
     |      Return the RGB color associated with the sprite.
     |  
     |  height
     |      Get the height in pixels of the sprite.
     |  
     |  hit_box
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  left
     |      Return the x coordinate of the left-side of the sprite's hit box.
     |  
     |  points
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  position
     |      Get the center x and y coordinates of the sprite.
     |      
     |      Returns:
     |          (center_x, center_y)
     |  
     |  radians
     |      Converts the degrees representation of self.angle into radians.
     |      :return: float
     |  
     |  right
     |      Return the x coordinate of the right-side of the sprite's hit box.
     |  
     |  scale
     |      Get the scale of the sprite.
     |  
     |  texture
     |  
     |  texture_transform
     |  
     |  top
     |      Return the y coordinate of the top of the sprite.
     |  
     |  width
     |      Get the width of the sprite.
    
    class PhysicsEnginePlatformer(builtins.object)
     |  PhysicsEnginePlatformer(player_sprite: arcade.sprite.Sprite, platforms: arcade.sprite_list.SpriteList, gravity_constant: float = 0.5, ladders: arcade.sprite_list.SpriteList = None)
     |  
     |  Simplistic physics engine for use in a platformer. It is easier to get
     |  started with this engine than more sophisticated engines like PyMunk. Note, it
     |  does not currently handle rotation.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, player_sprite: arcade.sprite.Sprite, platforms: arcade.sprite_list.SpriteList, gravity_constant: float = 0.5, ladders: arcade.sprite_list.SpriteList = None)
     |      Create a physics engine for a platformer.
     |      
     |      :param Sprite player_sprite: The moving sprite
     |      :param SpriteList platforms: The sprites it can't move through
     |      :param float gravity_constant: Downward acceleration per frame
     |      :param SpriteList ladders: Ladders the user can climb on
     |  
     |  can_jump(self, y_distance=5) -> bool
     |      Method that looks to see if there is a floor under
     |      the player_sprite. If there is a floor, the player can jump
     |      and we return a True.
     |      
     |      :returns: True if there is a platform below us
     |      :rtype: bool
     |  
     |  disable_multi_jump(self)
     |      Disables multi-jump.
     |      
     |      Calling this function also removes the requirement to
     |      call increment_jump_counter() every time the player jumps.
     |  
     |  enable_multi_jump(self, allowed_jumps: int)
     |      Enables multi-jump.
     |      allowed_jumps should include the initial jump.
     |      (1 allows only a single jump, 2 enables double-jump, etc)
     |      
     |      If you enable multi-jump, you MUST call increment_jump_counter()
     |      every time the player jumps. Otherwise they can jump infinitely.
     |      
     |      :param int allowed_jumps:
     |  
     |  increment_jump_counter(self)
     |      Updates the jump counter for multi-jump tracking
     |  
     |  is_on_ladder(self)
     |      Return 'true' if the player is in contact with a sprite in the ladder list.
     |  
     |  jump(self, velocity: int)
     |      Have the character jump.
     |  
     |  update(self)
     |      Move everything and resolve collisions.
     |      
     |      :Returns: SpriteList with all sprites contacted. Empty list if no sprites.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class PhysicsEngineSimple(builtins.object)
     |  PhysicsEngineSimple(player_sprite: arcade.sprite.Sprite, walls: arcade.sprite_list.SpriteList)
     |  
     |  Simplistic physics engine for use in games without gravity, such as top-down
     |  games. It is easier to get
     |  started with this engine than more sophisticated engines like PyMunk. Note, it
     |  does not currently handle rotation.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, player_sprite: arcade.sprite.Sprite, walls: arcade.sprite_list.SpriteList)
     |      Create a simple physics engine.
     |      
     |      :param Sprite player_sprite: The moving sprite
     |      :param SpriteList walls: The sprites it can't move through
     |  
     |  update(self)
     |      Move everything and resolve collisions.
     |      
     |      :Returns: SpriteList with all sprites contacted. Empty list if no sprites.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class PyMunk(builtins.object)
     |  Object used to hold pymunk info for a sprite.
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Set up pymunk object
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class PymunkPhysicsEngine(builtins.object)
     |  PymunkPhysicsEngine(gravity=(0, 0), damping: float = 1.0)
     |  
     |  Pymunk Physics Engine
     |  
     |  Methods defined here:
     |  
     |  __init__(self, gravity=(0, 0), damping: float = 1.0)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  add_collision_handler(self, first_type: str, second_type: str, begin_handler: Callable = None, pre_handler: Callable = None, post_handler: Callable = None, separate_handler: Callable = None)
     |      Add code to handle collisions between objects.
     |  
     |  add_sprite(self, sprite: arcade.sprite.Sprite, mass: float = 1, friction: float = 0.2, elasticity: Union[float, NoneType] = None, moment=None, body_type=0, damping=None, gravity=None, max_velocity=None, max_horizontal_velocity=None, max_vertical_velocity=None, radius: float = 0, collision_type: str = 'default')
     |      Add a sprite to the physics engine.
     |  
     |  add_sprite_list(self, sprite_list, mass: float = 1, friction: float = 0.2, elasticity: Union[float, NoneType] = None, moment=None, body_type=0, collision_type=None)
     |      Add all sprites in a sprite list to the physics engine.
     |  
     |  apply_force(self, sprite, force)
     |      Apply force to a Sprite.
     |  
     |  apply_impulse(self, sprite, impulse)
     |      Apply an impulse force on a sprite
     |  
     |  apply_opposite_running_force(self, sprite: arcade.sprite.Sprite)
     |      If a sprite goes left while on top of a dynamic sprite, that sprite
     |      should get pushed to the right.
     |  
     |  check_grounding(self, sprite: arcade.sprite.Sprite)
     |      See if the player is on the ground. Used to see if we can jump.
     |  
     |  get_physics_object(self, sprite: arcade.sprite.Sprite) -> arcade.pymunk_physics_engine.PymunkPhysicsObject
     |      Get the shape/body for a sprite.
     |  
     |  get_sprite_for_shape(self, shape) -> Union[arcade.sprite.Sprite, NoneType]
     |      Given a shape, what sprite is associated with it?
     |  
     |  get_sprites_from_arbiter(self, arbiter)
     |      Given a collision arbiter, return the sprites associated with the collision.
     |  
     |  is_on_ground(self, sprite)
     |      Return true of sprite is on top of something.
     |  
     |  remove_sprite(self, sprite: arcade.sprite.Sprite)
     |      Remove a sprite from the physics engine.
     |  
     |  resync_sprites(self)
     |      Set visual sprites to be the same location as physics engine sprites.
     |      Call this after stepping the pymunk physics engine
     |  
     |  set_friction(self, sprite, friction)
     |      Apply force to a Sprite.
     |  
     |  set_horizontal_velocity(self, sprite, velocity)
     |      Set a sprite's velocity
     |  
     |  set_position(self, sprite, position)
     |      Apply an impulse force on a sprite
     |  
     |  set_velocity(self, sprite, velocity)
     |      Apply an impulse force on a sprite
     |  
     |  step(self, delta_time: float = 0.016666666666666666, resync_sprites: bool = True)
     |      Tell the physics engine to perform calculations.
     |      
     |      :param float delta_time: Time to move the simulation forward. Keep this
     |                               value constant, do not use varying values for
     |                               each step.
     |      :param bool resync_sprites: Resynchronize Arcade graphical sprites to be
     |                                  at the same location as their Pymunk counterparts.
     |                                  If running multiple steps per frame, set this to
     |                                  false for the first steps, and true for the last
     |                                  step that's part of the update.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  DYNAMIC = 0
     |  
     |  KINEMATIC = 1
     |  
     |  MOMENT_INF = inf
     |  
     |  STATIC = 2
    
    class PymunkPhysicsObject(builtins.object)
     |  PymunkPhysicsObject(body: pymunk.body.Body = None, shape: pymunk.shapes.Shape = None)
     |  
     |  Object that holds pymunk body/shape for a sprite.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, body: pymunk.body.Body = None, shape: pymunk.shapes.Shape = None)
     |      Init
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Shape(builtins.object)
     |  Primitive drawing shape. This can be part of a ShapeElementList so
     |  shapes can be drawn faster in batch.
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  draw(self)
     |      Draw this shape. Drawing this way isn't as fast as drawing multiple
     |      shapes batched together in a ShapeElementList.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ShapeElementList(typing.Generic)
     |  ShapeElementList(*args, **kwds)
     |  
     |  A program can put multiple drawing primitives in a ShapeElementList, and then
     |  move and draw them as one. Do this when you want to create a more complex object
     |  out of simpler primitives. This also speeds rendering as all objects are drawn
     |  in one operation.
     |  
     |  Method resolution order:
     |      ShapeElementList
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __getitem__(self, i)
     |  
     |  __init__(self)
     |      Initialize the sprite list
     |  
     |  __iter__(self) -> Iterable[~TShape]
     |      Return an iterable object of sprites.
     |  
     |  __len__(self) -> int
     |      Return the length of the sprite list.
     |  
     |  append(self, item: ~TShape)
     |      Add a new shape to the list.
     |  
     |  draw(self)
     |      Draw everything in the list.
     |  
     |  move(self, change_x: float, change_y: float)
     |      Move all the shapes ion the list
     |      :param change_x: Amount to move on the x axis
     |      :param change_y: Amount to move on the y axis
     |  
     |  remove(self, item: ~TShape)
     |      Remove a specific shape from the list.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  angle
     |      Get the angle of the ShapeElementList in degrees.
     |  
     |  center_x
     |      Get the center x coordinate of the ShapeElementList.
     |  
     |  center_y
     |      Get the center y coordinate of the ShapeElementList.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __orig_bases__ = (typing.Generic[~TShape],)
     |  
     |  __parameters__ = (~TShape,)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from builtins.type
     |  
     |  __init_subclass__(*args, **kwargs) from builtins.type
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from typing.Generic:
     |  
     |  __new__(cls, *args, **kwds)
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class Sound(builtins.object)
     |  Sound(file_name: Union[str, pathlib.Path], streaming: bool = False)
     |  
     |  This class represents a sound you can play.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, file_name: Union[str, pathlib.Path], streaming: bool = False)
     |      Create and load the sound.
     |  
     |  get_length(self)
     |      Get length of audio in seconds
     |  
     |  get_stream_position(self)
     |      Return where we are in the stream. This will reset back to
     |      zero when it is done playing.
     |  
     |  get_volume(self)
     |      Get the current volume
     |  
     |  is_complete(self)
     |      Return true if the sound is done playing.
     |  
     |  play(self, volume=1.0, pan=0.0)
     |      Play the sound.
     |      
     |      :param float volume: Volume, from 0=quiet to 1=loud
     |      :param float pan: Pan, from -1=left to 0=centered to 1=right
     |  
     |  set_left_right_volume(self, left_volume, right_volume)
     |      Set absolute left/right volume
     |      
     |      This can only be done after the sound has started
     |      playing. Setting the sound volume when there is no sound playing generates
     |      a TypeError. If you want to set the volume before playing, use the ``volume``
     |      parameter in the ``play`` method.
     |  
     |  set_volume(self, volume)
     |      Set the current volume.
     |      
     |      This can only be done after the sound has started
     |      playing. Setting the sound volume when there is no sound playing generates
     |      a TypeError. If you want to set the volume before playing, use the ``volume``
     |      parameter in the ``play`` method.
     |  
     |  stop(self)
     |      Stop a currently playing sound.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Sprite(builtins.object)
     |  Sprite(filename: str = None, scale: float = 1, image_x: float = 0, image_y: float = 0, image_width: float = 0, image_height: float = 0, center_x: float = 0, center_y: float = 0, repeat_count_x: int = 1, repeat_count_y: int = 1, flipped_horizontally: bool = False, flipped_vertically: bool = False, flipped_diagonally: bool = False, mirrored: bool = None, hit_box_algorithm: str = 'Simple', hit_box_detail: float = 4.5)
     |  
     |  Class that represents a 'sprite' on-screen. Most games center around sprites.
     |  For examples on how to use this class, see:
     |  http://arcade.academy/examples/index.html#sprites
     |  
     |  Attributes:
     |      :alpha: Transparency of sprite. 0 is invisible, 255 is opaque.
     |      :angle: Rotation angle in degrees.
     |      :radians: Rotation angle in radians.
     |      :bottom: Set/query the sprite location by using the bottom coordinate.         This will be the 'y' of the bottom of the sprite.
     |      :boundary_left: Used in movement. Left boundary of moving sprite.
     |      :boundary_right: Used in movement. Right boundary of moving sprite.
     |      :boundary_top: Used in movement. Top boundary of moving sprite.
     |      :boundary_bottom: Used in movement. Bottom boundary of moving sprite.
     |      :center_x: X location of the center of the sprite
     |      :center_y: Y location of the center of the sprite
     |      :change_x: Movement vector, in the x direction.
     |      :change_y: Movement vector, in the y direction.
     |      :change_angle: Change in rotation.
     |      :color: Color tint the sprite
     |      :collision_radius: Used as a fast-check to see if this item is close         enough to another item. If this check works, we do a slower more accurate check.         You probably don't want to use this field. Instead, set points in the         hit box.
     |      :cur_texture_index: Index of current texture being used.
     |      :guid: Unique identifier for the sprite. Useful when debugging.
     |      :height: Height of the sprite.
     |      :force: Force being applied to the sprite. Useful when used with Pymunk         for physics.
     |      :left: Set/query the sprite location by using the left coordinate. This         will be the 'x' of the left of the sprite.
     |      :points: Points, in relation to the center of the sprite, that are used         for collision detection. Arcade defaults to creating points for a rectangle         that encompass the image. If you are creating a ramp or making better         hit-boxes, you can custom-set these.
     |      :position: A list with the (x, y) of where the sprite is.
     |      :repeat_count_x: Unused
     |      :repeat_count_y: Unused
     |      :right: Set/query the sprite location by using the right coordinate.         This will be the 'y=x' of the right of the sprite.
     |      :sprite_lists: List of all the sprite lists this sprite is part of.
     |      :texture: `Texture` class with the current texture.
     |      :textures: List of textures associated with this sprite.
     |      :top: Set/query the sprite location by using the top coordinate. This         will be the 'y' of the top of the sprite.
     |      :scale: Scale the image up or down. Scale of 1.0 is original size, 0.5         is 1/2 height and width.
     |      :velocity: Change in x, y expressed as a list. (0, 0) would be not moving.
     |      :width: Width of the sprite
     |  
     |  It is common to over-ride the `update` method and provide mechanics on
     |  movement or other sprite updates.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, filename: str = None, scale: float = 1, image_x: float = 0, image_y: float = 0, image_width: float = 0, image_height: float = 0, center_x: float = 0, center_y: float = 0, repeat_count_x: int = 1, repeat_count_y: int = 1, flipped_horizontally: bool = False, flipped_vertically: bool = False, flipped_diagonally: bool = False, mirrored: bool = None, hit_box_algorithm: str = 'Simple', hit_box_detail: float = 4.5)
     |      Create a new sprite.
     |      
     |      :param str filename: Filename of an image that represents the sprite.
     |      :param float scale: Scale the image up or down. Scale of 1.0 is none.
     |      :param float image_x: X offset to sprite within sprite sheet.
     |      :param float image_y: Y offset to sprite within sprite sheet.
     |      :param float image_width: Width of the sprite
     |      :param float image_height: Height of the sprite
     |      :param float center_x: Location of the sprite
     |      :param float center_y: Location of the sprite
     |      :param bool flipped_horizontally: Mirror the sprite image. Flip left/right across vertical axis.
     |      :param bool flipped_vertically: Flip the image up/down across the horizontal axis.
     |      :param bool flipped_diagonally: Transpose the image, flip it across the diagonal.
     |      :param mirrored: Deprecated.
     |      :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.         Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,         :data:`PhysicsEnginePlatformer`         and 'Detailed' for the :data:`PymunkPhysicsEngine`.
     |      
     |          .. figure:: images/hit_box_algorithm_none.png
     |             :width: 40%
     |      
     |             hit_box_algorithm = "None"
     |      
     |          .. figure:: images/hit_box_algorithm_simple.png
     |             :width: 55%
     |      
     |             hit_box_algorithm = "Simple"
     |      
     |          .. figure:: images/hit_box_algorithm_detailed.png
     |             :width: 75%
     |      
     |             hit_box_algorithm = "Detailed"
     |      :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  add_spatial_hashes(self)
     |      Add spatial hashes for this sprite in all the sprite lists it is part of.
     |  
     |  append_texture(self, texture: arcade.texture.Texture)
     |      Appends a new texture to the list of textures that can be
     |      applied to this sprite.
     |      
     |      :param arcade.Texture texture: Texture to add ot the list of available textures
     |  
     |  clear_spatial_hashes(self)
     |      Search the sprite lists this sprite is a part of, and remove it
     |      from any spatial hashes it is a part of.
     |  
     |  collides_with_list(self, sprite_list: 'SpriteList') -> list
     |      Check if current sprite is overlapping with any other sprite in a list
     |      
     |      Args:
     |          self: current Sprite
     |          sprite_list: SpriteList to check against
     |      
     |      Returns:
     |          SpriteList of all overlapping Sprites from the original SpriteList
     |  
     |  collides_with_point(self, point: Union[Tuple[float, float], List[float]]) -> bool
     |      Check if point is within the current sprite.
     |      
     |      Args:
     |          self: Current sprite
     |          point: Point to check.
     |      
     |      Returns:
     |          True if the point is contained within the sprite's boundary.
     |  
     |  collides_with_sprite(self, other: 'Sprite') -> bool
     |      Will check if a sprite is overlapping (colliding) another Sprite.
     |      
     |      Args:
     |          self: Current Sprite.
     |          other: The other sprite to check against.
     |      
     |      Returns:
     |          True or False, whether or not they are overlapping.
     |  
     |  draw(self)
     |      Draw the sprite.
     |  
     |  draw_hit_box(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0), line_thickness: float = 1)
     |      Draw a sprite's hit-box.
     |      
     |      The 'hit box' drawing is cached, so if you change the color/line thickness
     |      later, it won't take.
     |      
     |      :param color: Color of box
     |      :param line_thickness: How thick the box should be
     |  
     |  forward(self, speed: float = 1.0)
     |      Set a Sprite's position to speed by its angle
     |      :param speed: speed factor
     |  
     |  get_adjusted_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  get_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  get_points(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  kill(self)
     |      Alias of `remove_from_sprite_lists`
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pymunk_moved(self, physics_engine, dx, dy, d_angle)
     |      Called by the pymunk physics engine if this sprite moves.
     |  
     |  register_physics_engine(self, physics_engine)
     |      Called by the Pymunk physics engine when this sprite is added
     |      to that physics engine. Lets the sprite know about the engine and
     |      remove itself if it gets deleted.
     |  
     |  register_sprite_list(self, new_list)
     |      Register this sprite as belonging to a list. We will automatically
     |      remove ourselves from the the list when kill() is called.
     |  
     |  remove_from_sprite_lists(self)
     |      Remove the sprite from all sprite lists.
     |  
     |  rescale_relative_to_point(self, point: Union[Tuple[float, float], List[float]], factor: float) -> None
     |      Rescale the sprite relative to a different point than its center.
     |  
     |  reverse(self, speed: float = 1.0)
     |      Set a new speed, but in reverse.
     |      :param speed: speed factor
     |  
     |  set_hit_box(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hit box. Hit box should be relative to a sprite's center,
     |      and with a scale of 1.0.
     |      Points will be scaled with get_adjusted_hit_box.
     |  
     |  set_points(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hitbox
     |  
     |  set_position(self, center_x: float, center_y: float)
     |      Set a sprite's position
     |      
     |      :param float center_x: New x position of sprite
     |      :param float center_y: New y position of sprite
     |  
     |  set_texture(self, texture_no: int)
     |      Sets texture by texture id. Should be renamed because it takes
     |      a number rather than a texture, but keeping
     |      this for backwards compatibility.
     |  
     |  stop(self)
     |      Stop the Sprite's motion
     |  
     |  strafe(self, speed: float = 1.0)
     |      Set a sprites position perpendicular to its angle by speed
     |      :param speed: speed factor
     |  
     |  turn_left(self, theta: float = 90)
     |      Rotate the sprite left a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  turn_right(self, theta: float = 90)
     |      Rotate the sprite right a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  update(self)
     |      Update the sprite.
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Override this to add code that will change
     |      what image is shown, so the sprite can be
     |      animated.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  alpha
     |      Return the alpha associated with the sprite.
     |  
     |  angle
     |      Get the angle of the sprite's rotation.
     |  
     |  bottom
     |      Return the y coordinate of the bottom of the sprite.
     |  
     |  center_x
     |      Get the center x coordinate of the sprite.
     |  
     |  center_y
     |      Get the center y coordinate of the sprite.
     |  
     |  change_x
     |      Get the velocity in the x plane of the sprite.
     |  
     |  change_y
     |      Get the velocity in the y plane of the sprite.
     |  
     |  collision_radius
     |      Get the collision radius.
     |      
     |      .. note:: Final collision checking is done via geometry that was
     |          set in get_points/set_points. These points are used in the
     |          check_for_collision function. This collision_radius variable
     |          is used as a "pre-check." We do a super-fast check with
     |          collision_radius and see if the sprites are close. If they are,
     |          then we look at the geometry and figure if they really are colliding.
     |  
     |  color
     |      Return the RGB color associated with the sprite.
     |  
     |  height
     |      Get the height in pixels of the sprite.
     |  
     |  hit_box
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  left
     |      Return the x coordinate of the left-side of the sprite's hit box.
     |  
     |  points
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  position
     |      Get the center x and y coordinates of the sprite.
     |      
     |      Returns:
     |          (center_x, center_y)
     |  
     |  radians
     |      Converts the degrees representation of self.angle into radians.
     |      :return: float
     |  
     |  right
     |      Return the x coordinate of the right-side of the sprite's hit box.
     |  
     |  scale
     |      Get the scale of the sprite.
     |  
     |  texture
     |  
     |  texture_transform
     |  
     |  top
     |      Return the y coordinate of the top of the sprite.
     |  
     |  width
     |      Get the width of the sprite.
    
    class SpriteCircle(Sprite)
     |  SpriteCircle(radius: int, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], soft: bool = False)
     |  
     |  This sprite is just an elliptical sprite of one solid color. No need to
     |  use an image file.
     |  
     |  Method resolution order:
     |      SpriteCircle
     |      Sprite
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, radius: int, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], soft: bool = False)
     |      :param float radius: Radius of the circle
     |      :param Color color: Color of the circle
     |      :param bool soft: If True, will add a alpha gradient
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Sprite:
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  add_spatial_hashes(self)
     |      Add spatial hashes for this sprite in all the sprite lists it is part of.
     |  
     |  append_texture(self, texture: arcade.texture.Texture)
     |      Appends a new texture to the list of textures that can be
     |      applied to this sprite.
     |      
     |      :param arcade.Texture texture: Texture to add ot the list of available textures
     |  
     |  clear_spatial_hashes(self)
     |      Search the sprite lists this sprite is a part of, and remove it
     |      from any spatial hashes it is a part of.
     |  
     |  collides_with_list(self, sprite_list: 'SpriteList') -> list
     |      Check if current sprite is overlapping with any other sprite in a list
     |      
     |      Args:
     |          self: current Sprite
     |          sprite_list: SpriteList to check against
     |      
     |      Returns:
     |          SpriteList of all overlapping Sprites from the original SpriteList
     |  
     |  collides_with_point(self, point: Union[Tuple[float, float], List[float]]) -> bool
     |      Check if point is within the current sprite.
     |      
     |      Args:
     |          self: Current sprite
     |          point: Point to check.
     |      
     |      Returns:
     |          True if the point is contained within the sprite's boundary.
     |  
     |  collides_with_sprite(self, other: 'Sprite') -> bool
     |      Will check if a sprite is overlapping (colliding) another Sprite.
     |      
     |      Args:
     |          self: Current Sprite.
     |          other: The other sprite to check against.
     |      
     |      Returns:
     |          True or False, whether or not they are overlapping.
     |  
     |  draw(self)
     |      Draw the sprite.
     |  
     |  draw_hit_box(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0), line_thickness: float = 1)
     |      Draw a sprite's hit-box.
     |      
     |      The 'hit box' drawing is cached, so if you change the color/line thickness
     |      later, it won't take.
     |      
     |      :param color: Color of box
     |      :param line_thickness: How thick the box should be
     |  
     |  forward(self, speed: float = 1.0)
     |      Set a Sprite's position to speed by its angle
     |      :param speed: speed factor
     |  
     |  get_adjusted_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  get_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  get_points(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  kill(self)
     |      Alias of `remove_from_sprite_lists`
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pymunk_moved(self, physics_engine, dx, dy, d_angle)
     |      Called by the pymunk physics engine if this sprite moves.
     |  
     |  register_physics_engine(self, physics_engine)
     |      Called by the Pymunk physics engine when this sprite is added
     |      to that physics engine. Lets the sprite know about the engine and
     |      remove itself if it gets deleted.
     |  
     |  register_sprite_list(self, new_list)
     |      Register this sprite as belonging to a list. We will automatically
     |      remove ourselves from the the list when kill() is called.
     |  
     |  remove_from_sprite_lists(self)
     |      Remove the sprite from all sprite lists.
     |  
     |  rescale_relative_to_point(self, point: Union[Tuple[float, float], List[float]], factor: float) -> None
     |      Rescale the sprite relative to a different point than its center.
     |  
     |  reverse(self, speed: float = 1.0)
     |      Set a new speed, but in reverse.
     |      :param speed: speed factor
     |  
     |  set_hit_box(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hit box. Hit box should be relative to a sprite's center,
     |      and with a scale of 1.0.
     |      Points will be scaled with get_adjusted_hit_box.
     |  
     |  set_points(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hitbox
     |  
     |  set_position(self, center_x: float, center_y: float)
     |      Set a sprite's position
     |      
     |      :param float center_x: New x position of sprite
     |      :param float center_y: New y position of sprite
     |  
     |  set_texture(self, texture_no: int)
     |      Sets texture by texture id. Should be renamed because it takes
     |      a number rather than a texture, but keeping
     |      this for backwards compatibility.
     |  
     |  stop(self)
     |      Stop the Sprite's motion
     |  
     |  strafe(self, speed: float = 1.0)
     |      Set a sprites position perpendicular to its angle by speed
     |      :param speed: speed factor
     |  
     |  turn_left(self, theta: float = 90)
     |      Rotate the sprite left a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  turn_right(self, theta: float = 90)
     |      Rotate the sprite right a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  update(self)
     |      Update the sprite.
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Override this to add code that will change
     |      what image is shown, so the sprite can be
     |      animated.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Sprite:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  alpha
     |      Return the alpha associated with the sprite.
     |  
     |  angle
     |      Get the angle of the sprite's rotation.
     |  
     |  bottom
     |      Return the y coordinate of the bottom of the sprite.
     |  
     |  center_x
     |      Get the center x coordinate of the sprite.
     |  
     |  center_y
     |      Get the center y coordinate of the sprite.
     |  
     |  change_x
     |      Get the velocity in the x plane of the sprite.
     |  
     |  change_y
     |      Get the velocity in the y plane of the sprite.
     |  
     |  collision_radius
     |      Get the collision radius.
     |      
     |      .. note:: Final collision checking is done via geometry that was
     |          set in get_points/set_points. These points are used in the
     |          check_for_collision function. This collision_radius variable
     |          is used as a "pre-check." We do a super-fast check with
     |          collision_radius and see if the sprites are close. If they are,
     |          then we look at the geometry and figure if they really are colliding.
     |  
     |  color
     |      Return the RGB color associated with the sprite.
     |  
     |  height
     |      Get the height in pixels of the sprite.
     |  
     |  hit_box
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  left
     |      Return the x coordinate of the left-side of the sprite's hit box.
     |  
     |  points
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  position
     |      Get the center x and y coordinates of the sprite.
     |      
     |      Returns:
     |          (center_x, center_y)
     |  
     |  radians
     |      Converts the degrees representation of self.angle into radians.
     |      :return: float
     |  
     |  right
     |      Return the x coordinate of the right-side of the sprite's hit box.
     |  
     |  scale
     |      Get the scale of the sprite.
     |  
     |  texture
     |  
     |  texture_transform
     |  
     |  top
     |      Return the y coordinate of the top of the sprite.
     |  
     |  width
     |      Get the width of the sprite.
    
    class SpriteList(builtins.object)
     |  SpriteList(use_spatial_hash=None, spatial_hash_cell_size=128, is_static=False)
     |  
     |  Keep a list of sprites. Contains many optimizations around batch-drawing sprites
     |  and doing collision detection. For optimization reasons, use_spatial_hash and
     |  is_static are very important.
     |  
     |  Methods defined here:
     |  
     |  __getitem__(self, i)
     |  
     |  __init__(self, use_spatial_hash=None, spatial_hash_cell_size=128, is_static=False)
     |      Initialize the sprite list
     |      
     |      :param bool use_spatial_hash: If set to True, this will make moving a sprite
     |             in the SpriteList slower, but it will speed up collision detection
     |             with items in the SpriteList. Great for doing collision detection
     |             with static walls/platforms.
     |      :param int spatial_hash_cell_size:
     |      :param bool is_static: Speeds drawing if the sprites in the list do not
     |             move. Will result in buggy behavior if the sprites move when this
     |             is set to True.
     |  
     |  __iter__(self) -> Iterator[arcade.sprite.Sprite]
     |      Return an iterable object of sprites.
     |  
     |  __len__(self) -> int
     |      Return the length of the sprite list.
     |  
     |  __setitem__(self, key: int, value: arcade.sprite.Sprite)
     |  
     |  append(self, item: ~_SpriteType)
     |      Add a new sprite to the list.
     |      
     |      :param Sprite item: Sprite to add to the list.
     |  
     |  disable_spatial_hashing(self)
     |      Turn off spatial hashing.
     |  
     |  draw(self, **kwargs)
     |      Draw this list of sprites.
     |      
     |      :param filter: Optional parameter to set OpenGL filter, such as
     |                     `gl.GL_NEAREST` to avoid smoothing.
     |  
     |  draw_hit_boxes(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0, 255), line_thickness: float = 1)
     |      Draw all the hit boxes in this list
     |  
     |  enable_spatial_hashing(self, spatial_hash_cell_size=128)
     |      Turn on spatial hashing.
     |  
     |  extend(self, items: Union[list, ForwardRef('SpriteList')])
     |      Extends the current list with the given list
     |      
     |      :param list items: list of Sprites to add to the list
     |  
     |  index(self, key)
     |      Return the index of this sprite
     |  
     |  insert(self, index: int, item: ~_SpriteType)
     |      Inserts a sprite at a given index
     |      
     |      :param int index: The index at which to insert
     |      :param Sprite item: The sprite to insert
     |  
     |  move(self, change_x: float, change_y: float)
     |      Moves all Sprites in the list by the same amount.
     |      
     |      :param float change_x: Amount to change all x values by
     |      :param float change_y: Amount to change all y values by
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pop(self, index: int = -1) -> arcade.sprite.Sprite
     |      Pop off the last sprite, or the given index, from the list
     |  
     |  preload_textures(self, texture_list: List)
     |      Preload a set of textures that will be used for sprites in this
     |      sprite list.
     |      
     |      :param array texture_list: List of textures.
     |  
     |  remove(self, item: ~_SpriteType)
     |      Remove a specific sprite from the list.
     |      :param Sprite item: Item to remove from the list
     |  
     |  rescale(self, factor: float) -> None
     |      Rescale all sprites in the list relative to the spritelists center.
     |  
     |  reverse(self)
     |      Reverses the current list inplace
     |  
     |  update(self)
     |      Call the update() method on each sprite in the list.
     |  
     |  update_angle(self, sprite: arcade.sprite.Sprite)
     |      Called by the Sprite class to update the angle in this sprite.
     |      Necessary for batch drawing of items.
     |      
     |      :param Sprite sprite: Sprite to update.
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Call the update_animation in every sprite in the sprite list.
     |  
     |  update_color(self, sprite: arcade.sprite.Sprite)
     |      Called by the Sprite class to update position, angle, size and color
     |      of the specified sprite.
     |      Necessary for batch drawing of items.
     |      
     |      :param Sprite sprite: Sprite to update.
     |  
     |  update_height(self, sprite: arcade.sprite.Sprite)
     |      Called by the Sprite class to update the size/scale in this sprite.
     |      Necessary for batch drawing of items.
     |      
     |      :param Sprite sprite: Sprite to update.
     |  
     |  update_location(self, sprite: arcade.sprite.Sprite)
     |      Called by the Sprite class to update the location in this sprite.
     |      Necessary for batch drawing of items.
     |      
     |      :param Sprite sprite: Sprite to update.
     |  
     |  update_position(self, sprite: arcade.sprite.Sprite)
     |      Called by the Sprite class to update position, angle, size and color
     |      of the specified sprite.
     |      Necessary for batch drawing of items.
     |      
     |      :param Sprite sprite: Sprite to update.
     |  
     |  update_size(self, sprite: arcade.sprite.Sprite)
     |      Called by the Sprite class to update the size/scale in this sprite.
     |      Necessary for batch drawing of items.
     |      
     |      :param Sprite sprite: Sprite to update.
     |  
     |  update_texture(self, sprite)
     |      Make sure we update the texture for this sprite for the next batch
     |      drawing
     |  
     |  update_width(self, sprite: arcade.sprite.Sprite)
     |      Called by the Sprite class to update the size/scale in this sprite.
     |      Necessary for batch drawing of items.
     |      
     |      :param Sprite sprite: Sprite to update.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  center
     |      Get the mean center coordinates of all sprites in the list.
     |  
     |  percent_sprites_moved
     |      What percent of the sprites moved?
     |  
     |  use_spatial_hash
     |      Are we using a spatial hash?
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'array_of_images': typing.Union[typing.List[typing....
     |  
     |  next_texture_id = 0
    
    class SpriteSolidColor(Sprite)
     |  SpriteSolidColor(width: int, height: int, color)
     |  
     |  This sprite is just a rectangular sprite of one solid color. No need to
     |  use an image file.
     |  
     |  Method resolution order:
     |      SpriteSolidColor
     |      Sprite
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, width: int, height: int, color)
     |      Create a solid-color rectangular sprite.
     |      
     |      :param int width: Width of the sprite
     |      :param int height: Height of the sprite
     |      :param Color color: Color of the sprite
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Sprite:
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  add_spatial_hashes(self)
     |      Add spatial hashes for this sprite in all the sprite lists it is part of.
     |  
     |  append_texture(self, texture: arcade.texture.Texture)
     |      Appends a new texture to the list of textures that can be
     |      applied to this sprite.
     |      
     |      :param arcade.Texture texture: Texture to add ot the list of available textures
     |  
     |  clear_spatial_hashes(self)
     |      Search the sprite lists this sprite is a part of, and remove it
     |      from any spatial hashes it is a part of.
     |  
     |  collides_with_list(self, sprite_list: 'SpriteList') -> list
     |      Check if current sprite is overlapping with any other sprite in a list
     |      
     |      Args:
     |          self: current Sprite
     |          sprite_list: SpriteList to check against
     |      
     |      Returns:
     |          SpriteList of all overlapping Sprites from the original SpriteList
     |  
     |  collides_with_point(self, point: Union[Tuple[float, float], List[float]]) -> bool
     |      Check if point is within the current sprite.
     |      
     |      Args:
     |          self: Current sprite
     |          point: Point to check.
     |      
     |      Returns:
     |          True if the point is contained within the sprite's boundary.
     |  
     |  collides_with_sprite(self, other: 'Sprite') -> bool
     |      Will check if a sprite is overlapping (colliding) another Sprite.
     |      
     |      Args:
     |          self: Current Sprite.
     |          other: The other sprite to check against.
     |      
     |      Returns:
     |          True or False, whether or not they are overlapping.
     |  
     |  draw(self)
     |      Draw the sprite.
     |  
     |  draw_hit_box(self, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = (0, 0, 0), line_thickness: float = 1)
     |      Draw a sprite's hit-box.
     |      
     |      The 'hit box' drawing is cached, so if you change the color/line thickness
     |      later, it won't take.
     |      
     |      :param color: Color of box
     |      :param line_thickness: How thick the box should be
     |  
     |  forward(self, speed: float = 1.0)
     |      Set a Sprite's position to speed by its angle
     |      :param speed: speed factor
     |  
     |  get_adjusted_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  get_hit_box(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  get_points(self) -> Sequence[Union[Tuple[float, float], List[float]]]
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  kill(self)
     |      Alias of `remove_from_sprite_lists`
     |  
     |  on_update(self, delta_time: float = 0.016666666666666666)
     |      Update the sprite. Similar to update, but also takes a delta-time.
     |  
     |  pymunk_moved(self, physics_engine, dx, dy, d_angle)
     |      Called by the pymunk physics engine if this sprite moves.
     |  
     |  register_physics_engine(self, physics_engine)
     |      Called by the Pymunk physics engine when this sprite is added
     |      to that physics engine. Lets the sprite know about the engine and
     |      remove itself if it gets deleted.
     |  
     |  register_sprite_list(self, new_list)
     |      Register this sprite as belonging to a list. We will automatically
     |      remove ourselves from the the list when kill() is called.
     |  
     |  remove_from_sprite_lists(self)
     |      Remove the sprite from all sprite lists.
     |  
     |  rescale_relative_to_point(self, point: Union[Tuple[float, float], List[float]], factor: float) -> None
     |      Rescale the sprite relative to a different point than its center.
     |  
     |  reverse(self, speed: float = 1.0)
     |      Set a new speed, but in reverse.
     |      :param speed: speed factor
     |  
     |  set_hit_box(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hit box. Hit box should be relative to a sprite's center,
     |      and with a scale of 1.0.
     |      Points will be scaled with get_adjusted_hit_box.
     |  
     |  set_points(self, points: Sequence[Union[Tuple[float, float], List[float]]])
     |      Set a sprite's hitbox
     |  
     |  set_position(self, center_x: float, center_y: float)
     |      Set a sprite's position
     |      
     |      :param float center_x: New x position of sprite
     |      :param float center_y: New y position of sprite
     |  
     |  set_texture(self, texture_no: int)
     |      Sets texture by texture id. Should be renamed because it takes
     |      a number rather than a texture, but keeping
     |      this for backwards compatibility.
     |  
     |  stop(self)
     |      Stop the Sprite's motion
     |  
     |  strafe(self, speed: float = 1.0)
     |      Set a sprites position perpendicular to its angle by speed
     |      :param speed: speed factor
     |  
     |  turn_left(self, theta: float = 90)
     |      Rotate the sprite left a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  turn_right(self, theta: float = 90)
     |      Rotate the sprite right a certain number of degrees.
     |      :param theta: change in angle
     |  
     |  update(self)
     |      Update the sprite.
     |  
     |  update_animation(self, delta_time: float = 0.016666666666666666)
     |      Override this to add code that will change
     |      what image is shown, so the sprite can be
     |      animated.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Sprite:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  alpha
     |      Return the alpha associated with the sprite.
     |  
     |  angle
     |      Get the angle of the sprite's rotation.
     |  
     |  bottom
     |      Return the y coordinate of the bottom of the sprite.
     |  
     |  center_x
     |      Get the center x coordinate of the sprite.
     |  
     |  center_y
     |      Get the center y coordinate of the sprite.
     |  
     |  change_x
     |      Get the velocity in the x plane of the sprite.
     |  
     |  change_y
     |      Get the velocity in the y plane of the sprite.
     |  
     |  collision_radius
     |      Get the collision radius.
     |      
     |      .. note:: Final collision checking is done via geometry that was
     |          set in get_points/set_points. These points are used in the
     |          check_for_collision function. This collision_radius variable
     |          is used as a "pre-check." We do a super-fast check with
     |          collision_radius and see if the sprites are close. If they are,
     |          then we look at the geometry and figure if they really are colliding.
     |  
     |  color
     |      Return the RGB color associated with the sprite.
     |  
     |  height
     |      Get the height in pixels of the sprite.
     |  
     |  hit_box
     |      Get a sprite's hit box, unadjusted for translation, rotation, or scale.
     |  
     |  left
     |      Return the x coordinate of the left-side of the sprite's hit box.
     |  
     |  points
     |      Get the points that make up the hit box for the rect that makes up the
     |      sprite, including rotation and scaling.
     |  
     |  position
     |      Get the center x and y coordinates of the sprite.
     |      
     |      Returns:
     |          (center_x, center_y)
     |  
     |  radians
     |      Converts the degrees representation of self.angle into radians.
     |      :return: float
     |  
     |  right
     |      Return the x coordinate of the right-side of the sprite's hit box.
     |  
     |  scale
     |      Get the scale of the sprite.
     |  
     |  texture
     |  
     |  texture_transform
     |  
     |  top
     |      Return the y coordinate of the top of the sprite.
     |  
     |  width
     |      Get the width of the sprite.
    
    class Text(builtins.object)
     |  Class used for managing text.
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Texture(builtins.object)
     |  Texture(name: str, image: PIL.Image.Image = None, hit_box_algorithm: str = 'Simple', hit_box_detail: float = 4.5)
     |  
     |  Class that represents a texture.
     |  Usually created by the :class:`load_texture` or :class:`load_textures` commands.
     |  
     |  Attributes:
     |      :name: Unique name of the texture. Used by load_textures for caching.
     |             If you are manually creating a texture, you can just set this
     |             to whatever.
     |      :image: A :py:class:`PIL.Image.Image` object.
     |      :width: Width of the texture in pixels.
     |      :height: Height of the texture in pixels.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name: str, image: PIL.Image.Image = None, hit_box_algorithm: str = 'Simple', hit_box_detail: float = 4.5)
     |      Create a texture, given a PIL Image object.
     |      
     |      :param str name: Name of texture. Used for caching, so must be unique for each texture.
     |      :param PIL.Image.Image image: Image to use as a texture.
     |      :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.         Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,         :data:`PhysicsEnginePlatformer`         and 'Detailed' for the :data:`PymunkPhysicsEngine`.
     |      
     |          .. figure:: images/hit_box_algorithm_none.png
     |             :width: 40%
     |      
     |             hit_box_algorithm = "None"
     |      
     |          .. figure:: images/hit_box_algorithm_simple.png
     |             :width: 55%
     |      
     |             hit_box_algorithm = "Simple"
     |      
     |          .. figure:: images/hit_box_algorithm_detailed.png
     |             :width: 75%
     |      
     |             hit_box_algorithm = "Detailed"
     |      :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
     |  
     |  draw_scaled(self, center_x: float, center_y: float, scale: float = 1.0, angle: float = 0, alpha: int = 255)
     |      Draw the texture.
     |      
     |      :param float center_x: X location of where to draw the texture.
     |      :param float center_y: Y location of where to draw the texture.
     |      :param float scale: Scale to draw rectangle. Defaults to 1.
     |      :param float angle: Angle to rotate the texture by.
     |      :param int alpha: The transparency of the texture `(0-255)`.
     |  
     |  draw_sized(self, center_x: float, center_y: float, width: float, height: float, angle: float = 0, alpha: int = 255)
     |  
     |  draw_transformed(self, left: float, bottom: float, width: float, height: float, angle: float = 0, alpha: int = 255, texture_transform: arcade.texture.Matrix3x3 = <arcade.texture.Matrix3x3 object at 0x16E95CB8>)
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  height
     |      Height of the texture in pixels.
     |  
     |  hit_box_points
     |  
     |  width
     |      Width of the texture in pixels.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class View(builtins.object)
     |  View(window: arcade.application.Window = None)
     |  
     |  Support different views/screens in a window.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, window: arcade.application.Window = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  on_draw(self)
     |      Called when this view should draw
     |  
     |  on_hide_view(self)
     |      Called when this view is not shown anymore
     |  
     |  on_key_press(self, symbol: int, modifiers: int)
     |      Override this function to add key press functionality.
     |      
     |      :param int symbol: Key that was hit
     |      :param int modifiers: Bitwise 'and' of all modifiers (shift, ctrl, num lock)
     |                            pressed during this event. See :ref:`keyboard_modifiers`.
     |  
     |  on_key_release(self, _symbol: int, _modifiers: int)
     |      Override this function to add key release functionality.
     |      
     |      :param int _symbol: Key that was hit
     |      :param int _modifiers: Bitwise 'and' of all modifiers (shift, ctrl, num lock)
     |                             pressed during this event. See :ref:`keyboard_modifiers`.
     |  
     |  on_mouse_drag(self, x: float, y: float, dx: float, dy: float, _buttons: int, _modifiers: int)
     |      Override this function to add mouse button functionality.
     |      
     |      :param float x: x position of mouse
     |      :param float y: y position of mouse
     |      :param float dx: Change in x since the last time this method was called
     |      :param float dy: Change in y since the last time this method was called
     |      :param int _buttons: Which button is pressed
     |      :param int _modifiers: Bitwise 'and' of all modifiers (shift, ctrl, num lock)
     |                            pressed during this event. See :ref:`keyboard_modifiers`.
     |  
     |  on_mouse_motion(self, x: float, y: float, dx: float, dy: float)
     |      Override this function to add mouse functionality.
     |      
     |      :param float x: x position of mouse
     |      :param float y: y position of mouse
     |      :param float dx: Change in x since the last time this method was called
     |      :param float dy: Change in y since the last time this method was called
     |  
     |  on_mouse_press(self, x: float, y: float, button: int, modifiers: int)
     |      Override this function to add mouse button functionality.
     |      
     |      :param float x: x position of the mouse
     |      :param float y: y position of the mouse
     |      :param int button: What button was hit. One of:
     |                         arcade.MOUSE_BUTTON_LEFT, arcade.MOUSE_BUTTON_RIGHT,
     |                         arcade.MOUSE_BUTTON_MIDDLE
     |      :param int modifiers: Bitwise 'and' of all modifiers (shift, ctrl, num lock)
     |                            pressed during this event. See :ref:`keyboard_modifiers`.
     |  
     |  on_mouse_release(self, x: float, y: float, button: int, modifiers: int)
     |      Override this function to add mouse button functionality.
     |      
     |      :param float x:
     |      :param float y:
     |      :param int button:
     |      :param int modifiers: Bitwise 'and' of all modifiers (shift, ctrl, num lock)
     |                            pressed during this event. See :ref:`keyboard_modifiers`.
     |  
     |  on_mouse_scroll(self, x: int, y: int, scroll_x: int, scroll_y: int)
     |      User moves the scroll wheel.
     |      
     |      :param int x:
     |      :param int y:
     |      :param int scroll_x:
     |      :param int scroll_y:
     |  
     |  on_show(self)
     |      Called when this view is shown and if window dispatches a on_show event.
     |      (first time showing window or resize)
     |  
     |  on_show_view(self)
     |      Called when this view is shown
     |  
     |  on_update(self, delta_time: float)
     |      To be overridden
     |  
     |  update(self, delta_time: float)
     |      To be overridden
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Window(pyglet.window.win32.Win32Window)
     |  Window(width: int = 800, height: int = 600, title: str = 'Arcade Window', fullscreen: bool = False, resizable: bool = False, update_rate: Union[float, NoneType] = 0.016666666666666666, antialiasing: bool = True, screen: pyglet.canvas.win32.Win32Screen = None)
     |  
     |  The Window class forms the basis of most advanced games that use Arcade.
     |  It represents a window on the screen, and manages events.
     |  
     |  Method resolution order:
     |      Window
     |      pyglet.window.win32.Win32Window
     |      pyglet.window.BaseWindow
     |      pyglet.event.EventDispatcher
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, width: int = 800, height: int = 600, title: str = 'Arcade Window', fullscreen: bool = False, resizable: bool = False, update_rate: Union[float, NoneType] = 0.016666666666666666, antialiasing: bool = True, screen: pyglet.canvas.win32.Win32Screen = None)
     |      Construct a new window
     |      
     |      :param int width: Window width
     |      :param int height: Window height
     |      :param str title: Title (appears in title bar)
     |      :param bool fullscreen: Should this be full screen?
     |      :param bool resizable: Can the user resize the window?
     |      :param float update_rate: How frequently to update the window.
     |      :param bool antialiasing: Should OpenGL's anti-aliasing be enabled?
     |  
     |  activate(self)
     |      Activate this window.
     |  
     |  center_window(self)
     |      Center the window on the screen.
     |  
     |  clear(self)
     |      Clears the window with the configured background color
     |      set through :py:attr:`arcade.Window.background_color`.
     |  
     |  close(self)
     |      Close the Window.
     |  
     |  dispatch_events(self)
     |      Dispatch events
     |  
     |  flip(self)
     |      Swap OpenGL and backing buffers for double-buffered windows.
     |  
     |  get_location(self) -> Tuple[int, int]
     |      Return the X/Y coordinates of the window
     |      
     |      :returns: x, y of window location
     |  
     |  get_size(self) -> Tuple[int, int]
     |      Get the size of the window.
     |      
     |      :returns: (width, height)
     |  
     |  get_system_mouse_cursor(self, name)
     |      Get the system mouse cursor
     |  
     |  get_viewport(self) -> Tuple[float, float, float, float]
     |      Get the viewport. (What coordinates we can see.)
     |  
     |  maximize(self)
     |      Maximize  the window.
     |  
     |  minimize(self)
     |      Minimize the window.
     |  
     |  on_draw(self)
     |      Override this function to add your custom drawing code.
     |  
     |  on_key_press(self, symbol: int, modifiers: int)
     |      Override this function to add key press functionality.
     |      
     |      :param int symbol: Key that was hit
     |      :param int modifiers: Bitwise 'and' of all modifiers (shift, ctrl, num lock)
     |                            pressed during this event. See :ref:`keyboard_modifiers`.
     |  
     |  on_key_release(self, symbol: int, modifiers: int)
     |      Override this function to add key release functionality.
     |      
     |      :param int symbol: Key that was hit
     |      :param int modifiers: Bitwise 'and' of all modifiers (shift, ctrl, num lock)
     |                            pressed during this event. See :ref:`keyboard_modifiers`.
     |  
     |  on_mouse_drag(self, x: float, y: float, dx: float, dy: float, buttons: int, modifiers: int)
     |      Override this function to add mouse button functionality.
     |      
     |      :param float x: x position of mouse
     |      :param float y: y position of mouse
     |      :param float dx: Change in x since the last time this method was called
     |      :param float dy: Change in y since the last time this method was called
     |      :param int buttons: Which button is pressed
     |      :param int modifiers: Bitwise 'and' of all modifiers (shift, ctrl, num lock)
     |                            pressed during this event. See :ref:`keyboard_modifiers`.
     |  
     |  on_mouse_motion(self, x: float, y: float, dx: float, dy: float)
     |      Override this function to add mouse functionality.
     |      
     |      :param float x: x position of mouse
     |      :param float y: y position of mouse
     |      :param float dx: Change in x since the last time this method was called
     |      :param float dy: Change in y since the last time this method was called
     |  
     |  on_mouse_press(self, x: float, y: float, button: int, modifiers: int)
     |      Override this function to add mouse button functionality.
     |      
     |      :param float x: x position of the mouse
     |      :param float y: y position of the mouse
     |      :param int button: What button was hit. One of:
     |                         arcade.MOUSE_BUTTON_LEFT, arcade.MOUSE_BUTTON_RIGHT,
     |                         arcade.MOUSE_BUTTON_MIDDLE
     |      :param int modifiers: Bitwise 'and' of all modifiers (shift, ctrl, num lock)
     |                            pressed during this event. See :ref:`keyboard_modifiers`.
     |  
     |  on_mouse_release(self, x: float, y: float, button: int, modifiers: int)
     |      Override this function to add mouse button functionality.
     |      
     |      :param float x:
     |      :param float y:
     |      :param int button:
     |      :param int modifiers: Bitwise 'and' of all modifiers (shift, ctrl, num lock)
     |                            pressed during this event. See :ref:`keyboard_modifiers`.
     |  
     |  on_mouse_scroll(self, x: int, y: int, scroll_x: int, scroll_y: int)
     |      User moves the scroll wheel.
     |      
     |      :param int x:
     |      :param int y:
     |      :param int scroll_x:
     |      :param int scroll_y:
     |  
     |  on_resize(self, width: float, height: float)
     |      Override this function to add custom code to be called any time the window
     |      is resized. The only responsibility here is to update the viewport.
     |      
     |      :param float width: New width
     |      :param float height: New height
     |  
     |  on_update(self, delta_time: float)
     |      Move everything. Perform collision checks. Do all the game logic here.
     |      
     |      :param float delta_time: Time interval since the last time the function was called.
     |  
     |  set_caption(self, caption)
     |      Set the caption for the window.
     |  
     |  set_exclusive_keyboard(self, exclusive=True)
     |      Capture all keyboard input.
     |  
     |  set_exclusive_mouse(self, exclusive=True)
     |      Capture the mouse.
     |  
     |  set_fullscreen(self, fullscreen=True, screen=None, mode=None, width=None, height=None)
     |      Set if we are full screen or not.
     |      
     |      :param bool fullscreen:
     |      :param screen:
     |      :param mode:
     |      :param int width:
     |      :param int height:
     |  
     |  set_location(self, x, y)
     |      Set location of the window.
     |  
     |  set_max_size(self, width: float, height: float)
     |      Wrap the Pyglet window call to set maximum size
     |      
     |      :param float width: width in pixels.
     |      :param float height: height in pixels.
     |      :Raises ValueError:
     |  
     |  set_maximum_size(self, width, height)
     |      Set largest window size.
     |  
     |  set_min_size(self, width: float, height: float)
     |      Wrap the Pyglet window call to set minimum size
     |      
     |      :param float width: width in pixels.
     |      :param float height: height in pixels.
     |  
     |  set_minimum_size(self, width: int, height: int)
     |      Set smallest window size.
     |  
     |  set_mouse_platform_visible(self, platform_visible=None)
     |      This does something.
     |  
     |  set_mouse_visible(self, visible: bool = True)
     |      If true, user can see the mouse cursor while it is over the window. Set false,
     |      the mouse is not visible. Default is true.
     |      
     |      :param bool visible:
     |  
     |  set_size(self, width: float, height: float)
     |      Ignore the resizable flag and set the size
     |      
     |      :param float width:
     |      :param float height:
     |  
     |  set_update_rate(self, rate: float)
     |      Set how often the screen should be updated.
     |      For example, self.set_update_rate(1 / 60) will set the update rate to 60 fps
     |      
     |      :param float rate: Update frequency in seconds
     |  
     |  set_viewport(self, left: float, right: float, bottom: float, top: float)
     |      Set the viewport. (What coordinates we can see.
     |      Used to scale and/or scroll the screen.)
     |      
     |      :param Number left:
     |      :param Number right:
     |      :param Number bottom:
     |      :param Number top:
     |  
     |  set_visible(self, visible=True)
     |      Set if the window is visible or not. Normally, a program's window is visible.
     |      
     |      :param bool visible:
     |  
     |  set_vsync(self, vsync: bool)
     |      Set if we sync our draws to the monitors vertical sync rate.
     |  
     |  show_view(self, new_view: 'View')
     |      Select the view to show. Calling this function is the same as setting the
     |      :py:meth:`arcade.Window.current_view` attribute.
     |      
     |      :param View new_view: View to show
     |  
     |  switch_to(self)
     |      Switch the this window.
     |  
     |  test(self, frames: int = 10)
     |      Used by unit test cases. Runs the event loop a few times and stops.
     |      
     |      :param int frames:
     |  
     |  update(self, delta_time: float)
     |      Move everything. For better consistency in naming, use ``on_update`` instead.
     |      
     |      :param float delta_time: Time interval since the last time the function was called in seconds.
     |  
     |  use(self)
     |      Bind the window's framebuffer for rendering commands
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  ctx
     |      The OpenGL context for this window.
     |      
     |      :type: :py:class:`arcade.ArcadeContext`
     |  
     |  current_view
     |      This property returns the current view being shown.
     |      To set a different view, call the
     |      :py:meth:`arcade.Window.show_view` method.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  background_color
     |      Get or set the background color for this window.
     |      
     |      :type: Color
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyglet.window.win32.Win32Window:
     |  
     |  dispatch_pending_events(self)
     |  
     |  set_icon(self, *images)
     |      Set the window icon.
     |      
     |      If multiple images are provided, one with an appropriate size
     |      will be selected (if the correct size is not provided, the image
     |      will be scaled).
     |      
     |      Useful sizes to provide are 16x16, 32x32, 64x64 (Mac only) and
     |      128x128 (Mac only).
     |      
     |      :Parameters:
     |          `images` : sequence of `pyglet.image.AbstractImage`
     |              List of images to use for the window icon.
     |  
     |  set_mouse_position(self, x, y, absolute=False)
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyglet.window.win32.Win32Window:
     |  
     |  vsync
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyglet.window.BaseWindow:
     |  
     |  __del__(self)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  dispatch_event(self, *args)
     |      Dispatch a single event to the attached handlers.
     |      
     |      The event is propagated to all handlers from from the top of the stack
     |      until one returns `EVENT_HANDLED`.  This method should be used only by
     |      :py:class:`~pyglet.event.EventDispatcher` implementors; applications should call
     |      the ``dispatch_events`` method.
     |      
     |      Since pyglet 1.2, the method returns `EVENT_HANDLED` if an event
     |      handler returned `EVENT_HANDLED` or `EVENT_UNHANDLED` if all events
     |      returned `EVENT_UNHANDLED`.  If no matching event handlers are in the
     |      stack, ``False`` is returned.
     |      
     |      :Parameters:
     |          `event_type` : str
     |              Name of the event.
     |          `args` : sequence
     |              Arguments to pass to the event handler.
     |      
     |      :rtype: bool or None
     |      :return: (Since pyglet 1.2) `EVENT_HANDLED` if an event handler
     |          returned `EVENT_HANDLED`; `EVENT_UNHANDLED` if one or more event
     |          handlers were invoked but returned only `EVENT_UNHANDLED`;
     |          otherwise ``False``.  In pyglet 1.1 and earlier, the return value
     |          is always ``None``.
     |  
     |  draw_mouse_cursor(self)
     |      Draw the custom mouse cursor.
     |      
     |      If the current mouse cursor has ``drawable`` set, this method
     |      is called before the buffers are flipped to render it.
     |      
     |      This method always leaves the ``GL_MODELVIEW`` matrix as current,
     |      regardless of what it was set to previously.  No other GL state
     |      is affected.
     |      
     |      There is little need to override this method; instead, subclass
     |      :py:class:`MouseCursor` and provide your own
     |      :py:meth:`~MouseCursor.draw` method.
     |  
     |  get_framebuffer_size(self)
     |      Return the size in actual pixels of the Window framebuffer.
     |      
     |      When using HiDPI screens, the size of the Window's framebuffer
     |      can be higher than that of the Window size requested. If you
     |      are performing operations that require knowing the actual number
     |      of pixels in the window, this method should be used instead of
     |      :py:func:`Window.get_size()`. For example, setting the Window
     |      projection or setting the glViewport size.
     |      
     |      :rtype: (int, int)
     |      :return: The width and height of the Window viewport, in pixels.
     |  
     |  get_pixel_ratio(self)
     |      Return the framebuffer/window size ratio.
     |      
     |      Some platforms and/or window systems support subpixel scaling,
     |      making the framebuffer size larger than the window size.
     |      Retina screens on OS X and Gnome on Linux are some examples.
     |      
     |      On a Retina systems the returned ratio would usually be 2.0 as a
     |      window of size 500 x 500 would have a frambuffer of 1000 x 1000.
     |      Fractional values between 1.0 and 2.0, as well as values above
     |      2.0 may also be encountered.
     |      
     |      :rtype: float
     |      :return: The framebuffer/window size ratio
     |  
     |  get_viewport_size = get_framebuffer_size(self)
     |  
     |  on_close(self)
     |      Default on_close handler.
     |  
     |  set_mouse_cursor(self, cursor=None)
     |      Change the appearance of the mouse cursor.
     |      
     |      The appearance of the mouse cursor is only changed while it is
     |      within this window.
     |      
     |      :Parameters:
     |          `cursor` : `MouseCursor`
     |              The cursor to set, or None to restore the default cursor.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyglet.window.BaseWindow:
     |  
     |  caption
     |      The window caption (title).  Read-only.
     |      
     |      :type: str
     |  
     |  config
     |      A GL config describing the context of this window.  Read-only.
     |      
     |      :type: :py:class:`pyglet.gl.Config`
     |  
     |  context
     |      The OpenGL context attached to this window.  Read-only.
     |      
     |      :type: :py:class:`pyglet.gl.Context`
     |  
     |  display
     |      The display this window belongs to.  Read-only.
     |      
     |      :type: :py:class:`Display`
     |  
     |  fullscreen
     |      True if the window is currently fullscreen.  Read-only.
     |      
     |      :type: bool
     |  
     |  resizeable
     |      True if the window is resizable.  Read-only.
     |      
     |      :type: bool
     |  
     |  screen
     |      The screen this window is fullscreen in.  Read-only.
     |      
     |      :type: :py:class:`Screen`
     |  
     |  style
     |      The window style; one of the ``WINDOW_STYLE_*`` constants.
     |      Read-only.
     |      
     |      :type: int
     |  
     |  visible
     |      True if the window is currently visible.  Read-only.
     |      
     |      :type: bool
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyglet.window.BaseWindow:
     |  
     |  height
     |      The height of the window, in pixels.  Read-write.
     |      
     |      :type: int
     |  
     |  projection
     |      The OpenGL window projection. Read-write.
     |      
     |      The default window projection is orthographic (2D), but can
     |      be changed to a 3D or custom projection. Custom projections
     |      should subclass :py:class:`pyglet.window.Projection`. There
     |      are two default projection classes are also provided, which
     |      are :py:class:`pyglet.window.Projection3D` and
     |      :py:class:`pyglet.window.Projection3D`.
     |      
     |      :type: :py:class:`pyglet.window.Projection`
     |  
     |  width
     |      The width of the window, in pixels.  Read-write.
     |      
     |      :type: int
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyglet.window.BaseWindow:
     |  
     |  CURSOR_CROSSHAIR = 'crosshair'
     |  
     |  CURSOR_DEFAULT = None
     |  
     |  CURSOR_HAND = 'hand'
     |  
     |  CURSOR_HELP = 'help'
     |  
     |  CURSOR_NO = 'no'
     |  
     |  CURSOR_SIZE = 'size'
     |  
     |  CURSOR_SIZE_DOWN = 'size_down'
     |  
     |  CURSOR_SIZE_DOWN_LEFT = 'size_down_left'
     |  
     |  CURSOR_SIZE_DOWN_RIGHT = 'size_down_right'
     |  
     |  CURSOR_SIZE_LEFT = 'size_left'
     |  
     |  CURSOR_SIZE_LEFT_RIGHT = 'size_left_right'
     |  
     |  CURSOR_SIZE_RIGHT = 'size_right'
     |  
     |  CURSOR_SIZE_UP = 'size_up'
     |  
     |  CURSOR_SIZE_UP_DOWN = 'size_up_down'
     |  
     |  CURSOR_SIZE_UP_LEFT = 'size_up_left'
     |  
     |  CURSOR_SIZE_UP_RIGHT = 'size_up_right'
     |  
     |  CURSOR_TEXT = 'text'
     |  
     |  CURSOR_WAIT = 'wait'
     |  
     |  CURSOR_WAIT_ARROW = 'wait_arrow'
     |  
     |  WINDOW_STYLE_BORDERLESS = 'borderless'
     |  
     |  WINDOW_STYLE_DEFAULT = None
     |  
     |  WINDOW_STYLE_DIALOG = 'dialog'
     |  
     |  WINDOW_STYLE_TOOL = 'tool'
     |  
     |  event_types = ['on_key_press', 'on_key_release', 'on_text', 'on_text_m...
     |  
     |  has_exit = False
     |  
     |  invalid = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyglet.event.EventDispatcher:
     |  
     |  event(self, *args)
     |      Function decorator for an event handler.
     |      
     |      Usage::
     |      
     |          win = window.Window()
     |      
     |          @win.event
     |          def on_resize(self, width, height):
     |              # ...
     |      
     |      or::
     |      
     |          @win.event('on_resize')
     |          def foo(self, width, height):
     |              # ...
     |  
     |  pop_handlers(self)
     |      Pop the top level of event handlers off the stack.
     |  
     |  push_handlers(self, *args, **kwargs)
     |      Push a level onto the top of the handler stack, then attach zero or
     |      more event handlers.
     |      
     |      If keyword arguments are given, they name the event type to attach.
     |      Otherwise, a callable's `__name__` attribute will be used.  Any other
     |      object may also be specified, in which case it will be searched for
     |      callables with event names.
     |  
     |  remove_handler(self, name, handler)
     |      Remove a single event handler.
     |      
     |      The given event handler is removed from the first handler stack frame
     |      it appears in.  The handler must be the exact same callable as passed
     |      to `set_handler`, `set_handlers` or
     |      :py:meth:`~pyglet.event.EventDispatcher.push_handlers`; and the name
     |      must match the event type it is bound to.
     |      
     |      No error is raised if the event handler is not set.
     |      
     |      :Parameters:
     |          `name` : str
     |              Name of the event type to remove.
     |          `handler` : callable
     |              Event handler to remove.
     |  
     |  remove_handlers(self, *args, **kwargs)
     |      Remove event handlers from the event stack.
     |      
     |      See :py:meth:`~pyglet.event.EventDispatcher.push_handlers` for the
     |      accepted argument types. All handlers are removed from the first stack
     |      frame that contains any of the given handlers. No error is raised if
     |      any handler does not appear in that frame, or if no stack frame
     |      contains any of the given handlers.
     |      
     |      If the stack frame is empty after removing the handlers, it is
     |      removed from the stack.  Note that this interferes with the expected
     |      symmetry of :py:meth:`~pyglet.event.EventDispatcher.push_handlers` and
     |      :py:meth:`~pyglet.event.EventDispatcher.pop_handlers`.
     |  
     |  set_handler(self, name, handler)
     |      Attach a single event handler.
     |      
     |      :Parameters:
     |          `name` : str
     |              Name of the event type to attach to.
     |          `handler` : callable
     |              Event handler to attach.
     |  
     |  set_handlers(self, *args, **kwargs)
     |      Attach one or more event handlers to the top level of the handler
     |      stack.
     |      
     |      See :py:meth:`~pyglet.event.EventDispatcher.push_handlers` for the accepted argument types.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pyglet.event.EventDispatcher:
     |  
     |  register_event_type(name) from pyglet.window._WindowMetaclass
     |      Register an event type with the dispatcher.
     |      
     |      Registering event types allows the dispatcher to validate event
     |      handler names as they are attached, and to search attached objects for
     |      suitable handlers.
     |      
     |      :Parameters:
     |          `name` : str
     |              Name of the event to register.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyglet.event.EventDispatcher:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

FUNCTIONS
    are_polygons_intersecting(poly_a: Sequence[Union[Tuple[float, float], List[float]]], poly_b: Sequence[Union[Tuple[float, float], List[float]]]) -> bool
        Return True if two polygons intersect.
        
        :param PointList poly_a: List of points that define the first polygon.
        :param PointList poly_b: List of points that define the second polygon.
        :Returns: True or false depending if polygons intersect
        
        :rtype bool:
    
    astar_calculate_path(start_point: Union[Tuple[float, float], List[float]], end_point: Union[Tuple[float, float], List[float]], astar_barrier_list: arcade.paths.AStarBarrierList, diagonal_movement=True)
        :param Point start_point:
        :param Point end_point:
        :param AStarBarrierList astar_barrier_list:
        :param bool diagonal_movement:
        
        Returns: List
    
    calculate_hit_box_points_detailed(image: <module 'PIL.Image' from 'C:\\Users\\\\AppData\\Local\\Programs\\Python\\Python38-32\\lib\\site-packages\\PIL\\Image.py'>, hit_box_detail: float = 4.5)
        Given an image, this returns points that make up a hit box around it. Attempts
        to trim out transparent pixels.
        
        :param Image image: Image get hit box from.
        :param int hit_box_detail: How detailed to make the hit box. There's a
                                   trade-off in number of points vs. accuracy.
        
        :Returns: List of points
    
    calculate_hit_box_points_simple(image)
        Given an image, this returns points that make up a hit box around it. Attempts
        to trim out transparent pixels.
        
        :param Image image:
        
        :Returns: List of points
    
    check_for_collision(sprite1: arcade.sprite.Sprite, sprite2: arcade.sprite.Sprite) -> bool
        Check for a collision between two sprites.
        
        :param sprite1: First sprite
        :param sprite2: Second sprite
        
        :Returns: True or False depending if the sprites intersect.
    
    check_for_collision_with_list(sprite: arcade.sprite.Sprite, sprite_list: arcade.sprite_list.SpriteList) -> List[arcade.sprite.Sprite]
        Check for a collision between a sprite, and a list of sprites.
        
        :param Sprite sprite: Sprite to check
        :param SpriteList sprite_list: SpriteList to check against
        
        :returns: List of sprites colliding, or an empty list.
    
    clamp(a, low, high)
    
    cleanup_texture_cache()
        This cleans up the cache of textures. Useful when running unit tests so that
        the next test starts clean.
    
    close_window()
        Closes the current window, and then runs garbage collection. The garbage collection
        is necessary to prevent crashing when opening/closing windows rapidly (usually during
        unit tests).
    
    create_ellipse(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1, tilt_angle: float = 0, num_segments: int = 32, filled=True) -> arcade.buffered_draw_commands.Shape
        This creates an ellipse vertex buffer object (VBO).
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
    
    create_ellipse_filled(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], tilt_angle: float = 0, num_segments: int = 128) -> arcade.buffered_draw_commands.Shape
        Create a filled ellipse. Or circle if you use the same width and height.
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
    
    create_ellipse_filled_with_colors(center_x: float, center_y: float, width: float, height: float, outside_color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], inside_color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], tilt_angle: float = 0, num_segments: int = 32) -> arcade.buffered_draw_commands.Shape
        Draw an ellipse, and specify inside/outside color. Used for doing gradients.
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
        
        
        :param float center_x:
        :param float center_y:
        :param float width:
        :param float height:
        :param Color outside_color:
        :param float inside_color:
        :param float tilt_angle:
        :param int num_segments:
        
        :Returns Shape:
    
    create_ellipse_outline(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1, tilt_angle: float = 0, num_segments: int = 128) -> arcade.buffered_draw_commands.Shape
        Create an outline of an ellipse.
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
    
    create_isometric_grid_lines(width, height, tile_width, tile_height, color, line_width)
    
    create_line(start_x: float, start_y: float, end_x: float, end_y: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], line_width: float = 1) -> arcade.buffered_draw_commands.Shape
        Create a line to be rendered later. This works faster than draw_line because
        the vertexes are only loaded to the graphics card once, rather than each frame.
        
        :param float start_x:
        :param float start_y:
        :param float end_x:
        :param float end_y:
        :param Color color:
        :param float line_width:
        
        :Returns Shape:
    
    create_line_generic(point_list: Sequence[Union[Tuple[float, float], List[float]]], color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], shape_mode: int, line_width: float = 1) -> arcade.buffered_draw_commands.Shape
        This function is used by ``create_line_strip`` and ``create_line_loop``,
        just changing the OpenGL type for the line drawing.
    
    create_line_generic_with_colors(point_list: Sequence[Union[Tuple[float, float], List[float]]], color_list: Iterable[Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]]], shape_mode: int, line_width: float = 1) -> arcade.buffered_draw_commands.Shape
        This function is used by ``create_line_strip`` and ``create_line_loop``,
        just changing the OpenGL type for the line drawing.
        
        :param PointList point_list:
        :param Iterable[Color] color_list:
        :param float shape_mode:
        :param float line_width:
        
        :Returns Shape:
    
    create_line_loop(point_list: Sequence[Union[Tuple[float, float], List[float]]], color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], line_width: float = 1)
        Create a multi-point line loop to be rendered later. This works faster than draw_line because
        the vertexes are only loaded to the graphics card once, rather than each frame.
        
        :param PointList point_list:
        :param Color color:
        :param float line_width:
        
        :Returns Shape:
    
    create_line_strip(point_list: Sequence[Union[Tuple[float, float], List[float]]], color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], line_width: float = 1)
        Create a multi-point line to be rendered later. This works faster than draw_line because
        the vertexes are only loaded to the graphics card once, rather than each frame.
        
        Internally, thick lines are created by two triangles.
        
        :param PointList point_list:
        :param Color color:
        :param PointList line_width:
        
        :Returns Shape:
    
    create_lines(point_list: Sequence[Union[Tuple[float, float], List[float]]], color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], line_width: float = 1)
        Create a multi-point line loop to be rendered later. This works faster than draw_line because
        the vertexes are only loaded to the graphics card once, rather than each frame.
        
        :param PointList point_list:
        :param Color color:
        :param float line_width:
        
        :Returns Shape:
    
    create_lines_with_colors(point_list: Sequence[Union[Tuple[float, float], List[float]]], color_list: Sequence[Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]]], line_width: float = 1)
    
    create_orthogonal_projection(left, right, bottom, top, near, far, dtype=None)
        Creates an orthogonal projection matrix. Used internally with the
        OpenGL shaders.
        
        :param float left: The left of the near plane relative to the plane's center.
        :param float right: The right of the near plane relative to the plane's center.
        :param float top: The top of the near plane relative to the plane's center.
        :param float bottom: The bottom of the near plane relative to the plane's center.
        :param float near: The distance of the near plane from the camera's origin.
                           It is recommended that the near plane is set to 1.0 or above to avoid
                           rendering issues at close range.
        :param float far: The distance of the far plane from the camera's origin.
        :param dtype:
        :return: A projection matrix representing the specified orthogonal perspective.
        :rtype: numpy.array
        
        .. seealso:: http://msdn.microsoft.com/en-us/library/dd373965(v=vs.85).aspx
    
    create_polygon(point_list: Sequence[Union[Tuple[float, float], List[float]]], color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]])
        Draw a convex polygon. This will NOT draw a concave polygon.
        Because of this, you might not want to use this function.
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
        
        :param PointList point_list:
        :param color:
        
        :Returns Shape:
    
    create_rectangle(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1, tilt_angle: float = 0, filled=True) -> arcade.buffered_draw_commands.Shape
        This function creates a rectangle using a vertex buffer object.
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
        
        :param float center_x:
        :param float center_y:
        :param float width:
        :param float height:
        :param Color color:
        :param float border_width:
        :param float tilt_angle:
        :param bool filled:
    
    create_rectangle_filled(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], tilt_angle: float = 0) -> arcade.buffered_draw_commands.Shape
        Create a filled rectangle.
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
        
        :param float center_x:
        :param float center_y:
        :param float width:
        :param float height:
        :param Color color:
        :param float tilt_angle:
        
        :Returns Shape:
    
    create_rectangle_filled_with_colors(point_list, color_list) -> arcade.buffered_draw_commands.Shape
        This function creates one rectangle/quad using a vertex buffer object.
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
    
    create_rectangle_outline(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1, tilt_angle: float = 0) -> arcade.buffered_draw_commands.Shape
        Create a rectangle outline.
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
        
        Args:
            center_x:
            center_y:
            width:
            height:
            color:
            border_width:
            tilt_angle:
        
        Returns:
    
    create_rectangles_filled_with_colors(point_list, color_list) -> arcade.buffered_draw_commands.Shape
        This function creates multiple rectangle/quads using a vertex buffer object.
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
    
    create_text(text: str, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], font_size: float = 12, width: int = 0, align='left', font_name=('Calibri', 'Arial'), bold: bool = False, italic: bool = False, anchor_x: str = 'left', anchor_y: str = 'baseline', rotation=0)
        Deprecated. Two step text drawing for backwards compatibility.
    
    create_triangles_filled_with_colors(point_list, color_list) -> arcade.buffered_draw_commands.Shape
        This function creates multiple rectangle/quads using a vertex buffer object.
        
        The function returns a Shape object that can be drawn with ``my_shape.draw()``.
        Don't create the shape in the draw method, create it in the setup method and then
        draw it in ``on_draw``.
        
        For even faster performance, add multiple shapes into a ShapeElementList and
        draw that list. This allows nearly unlimited shapes to be drawn just as fast
        as one.
    
    draw_arc_filled(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], start_angle: float, end_angle: float, tilt_angle: float = 0, num_segments: int = 128)
        Draw a filled in arc. Useful for drawing pie-wedges, or Pac-Man.
        
        :param float center_x: x position that is the center of the arc.
        :param float center_y: y position that is the center of the arc.
        :param float width: width of the arc.
        :param float height: height of the arc.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float start_angle: start angle of the arc in degrees.
        :param float end_angle: end angle of the arc in degrees.
        :param float tilt_angle: angle the arc is tilted.
        :param float num_segments: Number of line segments used to draw arc.
    
    draw_arc_outline(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], start_angle: float, end_angle: float, border_width: float = 1, tilt_angle: float = 0, num_segments: int = 128)
        Draw the outside edge of an arc. Useful for drawing curved lines.
        
        :param float center_x: x position that is the center of the arc.
        :param float center_y: y position that is the center of the arc.
        :param float width: width of the arc.
        :param float height: height of the arc.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float start_angle: start angle of the arc in degrees.
        :param float end_angle: end angle of the arc in degrees.
        :param float border_width: width of line in pixels.
        :param float tilt_angle: angle the arc is tilted.
        :param int num_segments: float of triangle segments that make up this
             circle. Higher is better quality, but slower render time.
    
    draw_circle_filled(center_x: float, center_y: float, radius: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], num_segments: int = -1)
        Draw a filled-in circle.
        
        :param float center_x: x position that is the center of the circle.
        :param float center_y: y position that is the center of the circle.
        :param float radius: width of the circle.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param int num_segments: Number of triangle segments that make up this
             circle. Higher is better quality, but slower render time.
             The default value of -1 means arcade will try to calulate a reasonable
             amount of segments based on the size of the circle.
    
    draw_circle_outline(center_x: float, center_y: float, radius: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1, num_segments: int = -1)
        Draw the outline of a circle.
        
        :param float center_x: x position that is the center of the circle.
        :param float center_y: y position that is the center of the circle.
        :param float radius: width of the circle.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float border_width: Width of the circle outline in pixels.
        :param int num_segments: Number of triangle segments that make up this
             circle. Higher is better quality, but slower render time.
             The default value of -1 means arcade will try to calulate a reasonable
             amount of segments based on the size of the circle.
    
    draw_ellipse_filled(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], tilt_angle: float = 0, num_segments: int = -1)
        Draw a filled in ellipse.
        
        :param float center_x: x position that is the center of the circle.
        :param float center_y: y position that is the center of the circle.
        :param float width: width of the ellipse.
        :param float height: height of the ellipse.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float tilt_angle: Angle in degrees to tilt the ellipse.
        :param int num_segments: Number of triangle segments that make up this
             circle. Higher is better quality, but slower render time.
             The default value of -1 means arcade will try to calulate a reasonable
             amount of segments based on the size of the circle.
    
    draw_ellipse_outline(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1, tilt_angle: float = 0, num_segments: int = -1)
        Draw the outline of an ellipse.
        
        :param float center_x: x position that is the center of the circle.
        :param float center_y: y position that is the center of the circle.
        :param float width: width of the ellipse.
        :param float height: height of the ellipse.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float border_width: Width of the circle outline in pixels.
        :param float tilt_angle: Angle in degrees to tilt the ellipse.
        :param int num_segments: Number of triangle segments that make up this
             circle. Higher is better quality, but slower render time.
             The default value of -1 means arcade will try to calulate a reasonable
             amount of segments based on the size of the circle.
    
    draw_line(start_x: float, start_y: float, end_x: float, end_y: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], line_width: float = 1)
        Draw a line.
        
        :param float start_x: x position of line starting point.
        :param float start_y: y position of line starting point.
        :param float end_x: x position of line ending point.
        :param float end_y: y position of line ending point.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float line_width: Width of the line in pixels.
    
    draw_line_strip(point_list: Sequence[Union[Tuple[float, float], List[float]]], color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], line_width: float = 1)
        Draw a multi-point line.
        
        :param PointList point_list: List of x, y points that make up this strip
        :param Color color: Color of line strip
        :param float line_width: Width of the line
    
    draw_lines(point_list: Sequence[Union[Tuple[float, float], List[float]]], color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], line_width: float = 1)
        Draw a set of lines.
        
        Draw a line between each pair of points specified.
        
        :param PointList point_list: List of points making up the lines. Each point is
             in a list. So it is a list of lists.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float line_width: Width of the line in pixels.
    
    draw_lrtb_rectangle_filled(left: float, right: float, top: float, bottom: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]])
        Draw a rectangle by specifying left, right, top, and bottom edges.
        
        :param float left: The x coordinate of the left edge of the rectangle.
        :param float right: The x coordinate of the right edge of the rectangle.
        :param float top: The y coordinate of the top of the rectangle.
        :param float bottom: The y coordinate of the rectangle bottom.
        :param Color color: The color of the rectangle.
        :Raises AttributeError: Raised if left > right or top < bottom.
    
    draw_lrtb_rectangle_outline(left: float, right: float, top: float, bottom: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1)
        Draw a rectangle by specifying left, right, top, and bottom edges.
        
        :param float left: The x coordinate of the left edge of the rectangle.
        :param float right: The x coordinate of the right edge of the rectangle.
        :param float top: The y coordinate of the top of the rectangle.
        :param float bottom: The y coordinate of the rectangle bottom.
        :param Color color: The color of the rectangle.
        :param float border_width: The width of the border in pixels. Defaults to one.
        :Raises AttributeError: Raised if left > right or top < bottom.
    
    draw_lrwh_rectangle_textured(bottom_left_x: float, bottom_left_y: float, width: float, height: float, texture: arcade.texture.Texture, angle: float = 0, alpha: int = 255)
        Draw a texture extending from bottom left to top right.
        
        :param float bottom_left_x: The x coordinate of the left edge of the rectangle.
        :param float bottom_left_y: The y coordinate of the bottom of the rectangle.
        :param float width: The width of the rectangle.
        :param float height: The height of the rectangle.
        :param int texture: identifier of texture returned from load_texture() call
        :param float angle: rotation of the rectangle. Defaults to zero.
        :param int alpha: Transparency of image. 0 is fully transparent, 255 (default) is visible
    
    draw_parabola_filled(start_x: float, start_y: float, end_x: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], tilt_angle: float = 0)
        Draws a filled in parabola.
        
        :param float start_x: The starting x position of the parabola
        :param float start_y: The starting y position of the parabola
        :param float end_x: The ending x position of the parabola
        :param float height: The height of the parabola
        :param Color color: The color of the parabola
        :param float tilt_angle: The angle of the tilt of the parabola
    
    draw_parabola_outline(start_x: float, start_y: float, end_x: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1, tilt_angle: float = 0)
        Draws the outline of a parabola.
        
        :param float start_x: The starting x position of the parabola
        :param float start_y: The starting y position of the parabola
        :param float end_x: The ending x position of the parabola
        :param float height: The height of the parabola
        :param Color color: The color of the parabola
        :param float border_width: The width of the parabola
        :param float tilt_angle: The angle of the tilt of the parabola
    
    draw_point(x: float, y: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], size: float)
        Draw a point.
        
        :param float x: x position of point.
        :param float y: y position of point.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float size: Size of the point in pixels.
    
    draw_points(point_list: Sequence[Union[Tuple[float, float], List[float]]], color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], size: float = 1)
        Draw a set of points.
        
        :param PointList point_list: List of points Each point is
             in a list. So it is a list of lists.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float size: Size of the point in pixels.
    
    draw_polygon_filled(point_list: Sequence[Union[Tuple[float, float], List[float]]], color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]])
        Draw a polygon that is filled in.
        
        :param PointList point_list: List of points making up the lines. Each point is
             in a list. So it is a list of lists.
        :param Color color: The color, specified in RGB or RGBA format.
    
    draw_polygon_outline(point_list: Sequence[Union[Tuple[float, float], List[float]]], color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], line_width: float = 1)
        Draw a polygon outline. Also known as a "line loop."
        
        :param PointList point_list: List of points making up the lines. Each point is
             in a list. So it is a list of lists.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param int line_width: Width of the line in pixels.
    
    draw_rectangle_filled(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], tilt_angle: float = 0)
        Draw a filled-in rectangle.
        
        :param float center_x: x coordinate of rectangle center.
        :param float center_y: y coordinate of rectangle center.
        :param float width: width of the rectangle.
        :param float height: height of the rectangle.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float tilt_angle: rotation of the rectangle. Defaults to zero.
    
    draw_rectangle_outline(center_x: float, center_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1, tilt_angle: float = 0)
        Draw a rectangle outline.
        
        :param float center_x: x coordinate of top left rectangle point.
        :param float center_y: y coordinate of top left rectangle point.
        :param float width: width of the rectangle.
        :param float height: height of the rectangle.
        :param Color color: color, specified in a list of 3 or 4 bytes in RGB or
             RGBA format.
        :param float border_width: width of the lines, in pixels.
        :param float tilt_angle: rotation of the rectangle. Defaults to zero.
    
    draw_scaled_texture_rectangle(center_x: float, center_y: float, texture: arcade.texture.Texture, scale: float = 1.0, angle: float = 0, alpha: int = 255)
        Draw a textured rectangle on-screen.
        
        :param float center_x: x coordinate of rectangle center.
        :param float center_y: y coordinate of rectangle center.
        :param int texture: identifier of texture returned from load_texture() call
        :param float scale: scale of texture
        :param float angle: rotation of the rectangle. Defaults to zero.
        :param float alpha: Transparency of image. 0 is fully transparent, 255 (default) is visible
    
    draw_text(text: str, start_x: float, start_y: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], font_size: float = 12, width: int = 0, align: str = 'left', font_name: Union[str, Tuple[str, ...]] = ('calibri', 'arial'), bold: bool = False, italic: bool = False, anchor_x: str = 'left', anchor_y: str = 'baseline', rotation: float = 0) -> arcade.sprite.Sprite
        Draws text to the screen.
        
        Internally this works by creating an image, and using the Pillow library to
        draw the text to it. Then use that image to create a sprite. We cache the sprite
        (so we don't have to recreate over and over, which is slow) and use it to
        draw text to the screen.
        
        This implementation does not support bold/italic like the older Pyglet-based
        implementation of draw_text. However if you specify the 'italic' or 'bold'
        version of the font via the font name, you will get that font. Just the booleans
        do not work.
        
        :param str text: Text to draw
        :param float start_x: x coordinate of the lower-left point to start drawing text
        :param float start_y: y coordinate of the lower-left point to start drawing text
        :param Color color: Color of the text
        :param float font_size: Size of the text
        :param float width: Width of the text-box for the text to go into. Used with alignment.
        :param str align: Align left, right, center
        :param Union[str, Tuple[str, ...]] font_name: Font name, or list of font names in order of preference
        :param bool bold: Bold the font (currently unsupported)
        :param bool italic: Italicize the font (currently unsupported)
        :param str anchor_x: Anchor the font location, defaults to 'left'
        :param str anchor_y: Anchor the font location, defaults to 'baseline'
        :param float rotation: Rotate the text
    
    draw_text_2(text: str, start_x: float, start_y: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], font_size: float = 12, width: int = 0, align: str = 'left', font_name: Union[str, Tuple[str, ...]] = ('calibri', 'arial'), bold: bool = False, italic: bool = False, anchor_x: str = 'left', anchor_y: str = 'baseline', rotation: float = 0)
        Draws text to the screen using pyglet's label instead. Doesn't work.
        
        :param str text: Text to draw
        :param float start_x:
        :param float start_y:
        :param Color color: Color of the text
        :param float font_size: Size of the text
        :param float width:
        :param str align:
        :param Union[str, Tuple[str, ...]] font_name:
        :param bool bold:
        :param bool italic:
        :param str anchor_x:
        :param str anchor_y:
        :param float rotation:
    
    draw_texture_rectangle(center_x: float, center_y: float, width: float, height: float, texture: arcade.texture.Texture, angle: float = 0, alpha: int = 255)
        Draw a textured rectangle on-screen.
        
        :param float center_x: x coordinate of rectangle center.
        :param float center_y: y coordinate of rectangle center.
        :param float width: width of texture
        :param float height: height of texture
        :param int texture: identifier of texture returned from load_texture() call
        :param float angle: rotation of the rectangle. Defaults to zero.
        :param float alpha: Transparency of image. 0 is fully transparent, 255 (default) is visible
    
    draw_triangle_filled(x1: float, y1: float, x2: float, y2: float, x3: float, y3: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]])
        Draw a filled in triangle.
        
        :param float x1: x value of first coordinate.
        :param float y1: y value of first coordinate.
        :param float x2: x value of second coordinate.
        :param float y2: y value of second coordinate.
        :param float x3: x value of third coordinate.
        :param float y3: y value of third coordinate.
        :param Color color: Color of triangle.
    
    draw_triangle_outline(x1: float, y1: float, x2: float, y2: float, x3: float, y3: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1)
        Draw a the outline of a triangle.
        
        :param float x1: x value of first coordinate.
        :param float y1: y value of first coordinate.
        :param float x2: x value of second coordinate.
        :param float y2: y value of second coordinate.
        :param float x3: x value of third coordinate.
        :param float y3: y value of third coordinate.
        :param Color color: Color of triangle.
        :param float border_width: Width of the border in pixels. Defaults to 1.
    
    draw_xywh_rectangle_filled(bottom_left_x: float, bottom_left_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]])
        Draw a filled rectangle extending from bottom left to top right
        
        :param float bottom_left_x: The x coordinate of the left edge of the rectangle.
        :param float bottom_left_y: The y coordinate of the bottom of the rectangle.
        :param float width: The width of the rectangle.
        :param float height: The height of the rectangle.
        :param Color color: The color of the rectangle.
    
    draw_xywh_rectangle_outline(bottom_left_x: float, bottom_left_y: float, width: float, height: float, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], border_width: float = 1)
        Draw a rectangle extending from bottom left to top right
        
        :param float bottom_left_x: The x coordinate of the left edge of the rectangle.
        :param float bottom_left_y: The y coordinate of the bottom of the rectangle.
        :param float width: The width of the rectangle.
        :param float height: The height of the rectangle.
        :param Color color: The color of the rectangle.
        :param float border_width: The width of the border in pixels. Defaults to one.
    
    earclip(polygon)
        Simple earclipping algorithm for a given polygon p.
        polygon is expected to be an array of 2-tuples of the cartesian points of the polygon
        For a polygon with n points it will return n-2 triangles.
        The triangles are returned as an array of 3-tuples where each item in the tuple is a 2-tuple of the cartesian point.
        
        Implementation Reference:
            - https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
    
    finish_render()
        Swap buffers and displays what has been drawn.
        If programs use derive from the Window class, this function is
        automatically called.
    
    get_closest_sprite(sprite: arcade.sprite.Sprite, sprite_list: arcade.sprite_list.SpriteList) -> Union[Tuple[arcade.sprite.Sprite, float], NoneType]
        Given a Sprite and SpriteList, returns the closest sprite, and its distance.
        
        :param Sprite sprite: Target sprite
        :param SpriteList sprite_list: List to search for closest sprite.
        
        :return: Closest sprite.
        :rtype: Sprite
    
    get_display_size(screen_id: int = 0) -> Tuple[int, int]
        Return the width and height of a monitor.
        
        The size of the primary monitor is returned by default.
        
        :param int screen_id: The screen number
        :return: Tuple containing the width and height of the screen
        :rtype: tuple
    
    get_distance(x1: float, y1: float, x2: float, y2: float)
        Get the distance between two points.
    
    get_distance_between_sprites(sprite1: arcade.sprite.Sprite, sprite2: arcade.sprite.Sprite) -> float
        Returns the distance between the center of two given sprites
        :param Sprite sprite1: Sprite one
        :param Sprite sprite2: Sprite two
        :return: Distance
        :rtype: float
    
    get_four_byte_color(color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]]) -> Union[Tuple[int, int, int, int], List[int]]
        Given a RGB list, it will return RGBA.
        Given a RGBA list, it will return the same RGBA.
        
        :param Color color: Three or four byte tuple
        
        :returns:  return: Four byte RGBA tuple
    
    get_four_float_color(color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]]) -> Tuple[float, float, float, float]
        Given a 3 or 4 RGB/RGBA color where each color goes 0-255, this
        returns a RGBA tuple where each item is a scaled float from 0 to 1.
        
        :param Color color: Three or four byte tuple
        :return: Four floats as a RGBA tuple
    
    get_game_controllers()
        Get a list of all the game controllers
        
        :return: List of game controllers
    
    get_image(x: int = 0, y: int = 0, width: int = None, height: int = None)
        Get an image from the screen.
        
        :param int x: Start (left) x location
        :param int y: Start (top) y location
        :param int width: Width of image. Leave blank for grabbing the 'rest' of the image
        :param int height: Height of image. Leave blank for grabbing the 'rest' of the image
        
        You can save the image like:
        
        .. highlight:: python
        .. code-block:: python
        
            image = get_image()
            image.save('screenshot.png', 'PNG')
    
    get_joysticks()
        Get a list of all the game controllers
        
        This is an alias of ``get_game_controllers``, which is better worded.
        
        :return: List of game controllers
    
    get_pixel(x: int, y: int) -> Tuple[int, int, int]
        Given an x, y, will return RGB color value of that point.
        
        :param int x: x location
        :param int y: y location
        :returns: Color
    
    get_points_for_thick_line(start_x: float, start_y: float, end_x: float, end_y: float, line_width: float)
        Function used internally for Arcade. OpenGL draws triangles only, so a think
        line must be two triangles that make up a rectangle. This calculates those
        points.
    
    get_projection()
        Returns the current projection matrix used by sprites and shapes in arcade.
        
        This is a shortcut for ```window.ctx.projection_2d_matrix``.
        
        :return: Numpy array with projection.
    
    get_rectangle_points(center_x: float, center_y: float, width: float, height: float, tilt_angle: float = 0) -> Sequence[Union[Tuple[float, float], List[float]]]
        Utility function that will return all four coordinate points of a
        rectangle given the x, y center, width, height, and rotation.
        
        Args:
            center_x:
            center_y:
            width:
            height:
            tilt_angle:
        
        Returns:
    
    get_scaling_factor(window=None) -> float
        Gets the scaling factor of the given Window.
        This is the ratio between the window and framebuffer size.
        If no window is supplied the currently active window will be used.
        
        :param Window window: Handle to window we want to get scaling factor of.
        
        :return: Scaling factor. E.g., 2 would indicate scaled up twice.
        :rtype: float
    
    get_screens()
        Return a list of screens. So for a two-monitor setup, this should return
        a list of two screens. Can be used with arcade.Window to select which
        window we full-screen on.
    
    get_sprites_at_exact_point(point: Union[Tuple[float, float], List[float]], sprite_list: arcade.sprite_list.SpriteList) -> List[arcade.sprite.Sprite]
        Get a list of sprites at a particular point
        
        :param Point point: Point to check
        :param SpriteList sprite_list: SpriteList to check against
        
        :returns: List of sprites colliding, or an empty list.
    
    get_sprites_at_point(point: Union[Tuple[float, float], List[float]], sprite_list: arcade.sprite_list.SpriteList) -> List[arcade.sprite.Sprite]
        Get a list of sprites at a particular point
        
        :param Point point: Point to check
        :param SpriteList sprite_list: SpriteList to check against
        
        :returns: List of sprites colliding, or an empty list.
    
    get_text_image(text: str, text_color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], font_size: float = 12, width: int = 0, align: str = 'left', valign: str = 'top', font_name: Union[str, Tuple[str, ...]] = ('calibri', 'arial'), background_color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]] = None, height: int = 0)
    
    get_tilemap_layer(map_object: pytiled_parser.objects.TileMap, layer_path: str) -> Union[pytiled_parser.objects.Layer, NoneType]
        Given a TileMap and a layer path, this returns the TileLayer.
        
        :param pytiled_parser.objects.TileMap map_object: The map read in by the read_tmx function.
        :param str layer_path: A string to match the layer name. Case sensitive.
        
        :returns: A TileLayer, or None if no layer was found.
    
    get_viewport() -> Tuple[float, float, float, float]
        Get the current viewport settings.
        
        :return: Tuple of floats, with ``(left, right, bottom, top)``
    
    get_window() -> pyglet.window.win32.Win32Window
        Return a handle to the current window.
        
        :return: Handle to the current window.
    
    has_line_of_sight(point_1: Union[Tuple[float, float], List[float]], point_2: Union[Tuple[float, float], List[float]], walls: arcade.sprite_list.SpriteList, max_distance: int = -1, check_resolution: int = 2)
        Determine if we have line of sight between two points. Try to make sure
        that spatial hashing is enabled on the wall SpriteList or this will be
        very slow.
        
        :param Point point_1: Start position
        :param Point point_2: End position position
        :param SpriteList walls: List of all blocking sprites
        :param int max_distance: Max distance point 1 can see
        :param int check_resolution: Check every x pixels for a sprite. Trade-off
                                     between accuracy and speed.
    
    is_point_in_polygon(x, y, polygon_point_list)
        Use ray-tracing to see if point is inside a polygon
        
        Args:
            x:
            y:
            polygon_point_list:
        
        Returns: bool
    
    isometric_grid_to_screen(tile_x, tile_y, width, height, tile_width, tile_height)
    
    lerp(v1: float, v2: float, u: float) -> float
        linearly interpolate between two values
    
    lerp_vec(v1: Union[Tuple[float, float], List[float]], v2: Union[Tuple[float, float], List[float]], u: float) -> Union[Tuple[float, float], List[float]]
    
    load_sound(path: Union[str, pathlib.Path])
        Load a sound.
        
        :param str path: Name of the sound file to load.
        
        :returns: Sound object
        :rtype: Sound
    
    load_spritesheet(file_name: Union[str, pathlib.Path], sprite_width: int, sprite_height: int, columns: int, count: int, margin: int = 0) -> List[arcade.texture.Texture]
        :param str file_name: Name of the file to that holds the texture.
        :param int sprite_width: Width of the sprites in pixels
        :param int sprite_height: Height of the sprites in pixels
        :param int columns: Number of tiles wide the image is.
        :param int count: Number of tiles in the image.
        :param int margin: Margin between images
        
        :returns List: List of :class:`Texture` objects.
    
    load_texture(file_name: Union[str, pathlib.Path], x: float = 0, y: float = 0, width: float = 0, height: float = 0, flipped_horizontally: bool = False, flipped_vertically: bool = False, flipped_diagonally: bool = False, can_cache: bool = True, mirrored=None, hit_box_algorithm='Simple', hit_box_detail: float = 4.5) -> arcade.texture.Texture
        Load an image from disk and create a texture.
        
        Note: If the code is to load only part of the image, the given `x`, `y`
        coordinates will start with the origin `(0, 0)` in the upper left of the
        image. When drawing, Arcade uses `(0, 0)` in the lower left corner.
        Be careful with this reversal.
        
        For a longer explanation of why computers sometimes start in the upper
        left, see:
        http://programarcadegames.com/index.php?chapter=introduction_to_graphics&lang=en#section_5
        
        :param str file_name: Name of the file to that holds the texture.
        :param float x: X position of the crop area of the texture.
        :param float y: Y position of the crop area of the texture.
        :param float width: Width of the crop area of the texture.
        :param float height: Height of the crop area of the texture.
        :param bool flipped_horizontally: Mirror the sprite image. Flip left/right across vertical axis.
        :param bool flipped_vertically: Flip the image up/down across the horizontal axis.
        :param bool flipped_diagonally: Transpose the image, flip it across the diagonal.
        :param bool can_cache: If a texture has already been loaded, load_texture will return the same texture in order     to save time. Sometimes this is not desirable, as resizing a cached texture will cause all other textures to     resize with it. Setting can_cache to false will prevent this issue at the experience of additional resources.
        :param bool mirrored: Deprecated.
        :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.     Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,     :data:`PhysicsEnginePlatformer`     and 'Detailed' for the :data:`PymunkPhysicsEngine`.
        
            .. figure:: images/hit_box_algorithm_none.png
               :width: 40%
        
               hit_box_algorithm = "None"
        
            .. figure:: images/hit_box_algorithm_simple.png
               :width: 55%
        
               hit_box_algorithm = "Simple"
        
            .. figure:: images/hit_box_algorithm_detailed.png
               :width: 75%
        
               hit_box_algorithm = "Detailed"
        :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
        
        :returns: New :class:`Texture` object.
        
        :raises: ValueError
    
    load_texture_pair(filename, hit_box_algorithm: str = 'Simple')
        Load a texture pair, with the second being a mirror image of the first.
        Useful when doing animations and the character can face left/right.
    
    load_textures(file_name: Union[str, pathlib.Path], image_location_list: Union[Tuple[Union[Tuple[float, float, float, float], List[float]], ...], List[Union[Tuple[float, float, float, float], List[float]]]], mirrored: bool = False, flipped: bool = False) -> List[arcade.texture.Texture]
        Load a set of textures from a single image file.
        
        Note: If the code is to load only part of the image, the given `x`, `y`
        coordinates will start with the origin `(0, 0)` in the upper left of the
        image. When drawing, Arcade uses `(0, 0)` in the lower left corner.
        Be careful with this reversal.
        
        For a longer explanation of why computers sometimes start in the upper
        left, see:
        http://programarcadegames.com/index.php?chapter=introduction_to_graphics&lang=en#section_5
        
        :param str file_name: Name of the file.
        :param List image_location_list: List of image sub-locations. Each rectangle should be
               a `List` of four floats: `[x, y, width, height]`.
        :param bool mirrored: If set to `True`, the image is mirrored left to right.
        :param bool flipped: If set to `True`, the image is flipped upside down.
        
        :returns: List of :class:`Texture`'s.
        
        :raises: ValueError
    
    make_burst_emitter(center_xy: Union[Tuple[float, float], List[float]], filenames_and_textures: Sequence[Union[str, arcade.texture.Texture]], particle_count: int, particle_speed: float, particle_lifetime_min: float, particle_lifetime_max: float, particle_scale: float = 1.0, fade_particles: bool = True)
        Returns an emitter that emits all of its particles at once
    
    make_circle_texture(diameter: int, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]]) -> arcade.texture.Texture
        Return a Texture of a circle with the given diameter and color.
        
        :param int diameter: Diameter of the circle and dimensions of the square :class:`Texture` returned.
        :param Color color: Color of the circle.
        
        :returns: New :class:`Texture` object.
    
    make_interval_emitter(center_xy: Union[Tuple[float, float], List[float]], filenames_and_textures: Sequence[Union[str, arcade.texture.Texture]], emit_interval: float, emit_duration: float, particle_speed: float, particle_lifetime_min: float, particle_lifetime_max: float, particle_scale: float = 1.0, fade_particles: bool = True)
        Returns an emitter that emits its particles at a constant rate for a given amount of time
    
    make_soft_circle_texture(diameter: int, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], center_alpha: int = 255, outer_alpha: int = 0) -> arcade.texture.Texture
        Return a :class:`Texture` of a circle with the given diameter and color, fading out at its edges.
        
        :param int diameter: Diameter of the circle and dimensions of the square :class:`Texture` returned.
        :param Color color: Color of the circle.
        :param int center_alpha: Alpha value of the circle at its center.
        :param int outer_alpha: Alpha value of the circle at its edges.
        
        :returns: New :class:`Texture` object.
    
    make_soft_square_texture(size: int, color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], center_alpha: int = 255, outer_alpha: int = 0) -> arcade.texture.Texture
        Return a :class:`Texture` of a square with the given diameter and color, fading out at its edges.
        
        :param int size: Diameter of the square and dimensions of the square Texture returned.
        :param Color color: Color of the square.
        :param int center_alpha: Alpha value of the square at its center.
        :param int outer_alpha: Alpha value of the square at its edges.
        
        :returns: New :class:`Texture` object.
    
    make_transparent_color(color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]], transparency: float)
        Given a RGB color, along with an alpha, returns a RGBA color tuple.
        
        :param Color color: Three or four byte RGBA color
        :param float transparency: Transparency
    
    open_window(width: int, height: int, window_title: str, resizable: bool = False, antialiasing: bool = True) -> arcade.application.Window
        This function opens a window. For ease-of-use we assume there will only be one window, and the
        programmer does not need to keep a handle to the window. This isn't the best architecture, because
        the window handle is stored in a global, but it makes things easier for programmers if they don't
        have to track a window pointer.
        
        :param Number width: Width of the window.
        :param Number height: Height of the window.
        :param str window_title: Title of the window.
        :param bool resizable: Whether the window can be user-resizable.
        :param bool antialiasing: Smooth the graphics?
        
        :returns: Handle to window
        :rtype arcade.Window:
    
    pause(seconds: numbers.Number)
        Pause for the specified number of seconds. This is a convenience function that just calls time.sleep()
        
        :param float seconds: Time interval to pause in seconds.
    
    play_sound(sound: arcade.sound.Sound, volume: float = 1.0, pan: float = 0.0)
        Play a sound.
        
        :param Sound sound: Sound loaded by load_sound. Do NOT use a string here for the filename.
        :param float volume: Volume, from 0=quiet to 1=loud
        :param float pan: Pan, from -1=left to 0=centered to 1=right
    
    process_layer(map_object: pytiled_parser.objects.TileMap, layer_name: str, scaling: float = 1, base_directory: str = '', use_spatial_hash: Union[bool, NoneType] = None, hit_box_algorithm='Simple', hit_box_detail: float = 4.5) -> arcade.sprite_list.SpriteList
        This takes a map layer returned by the read_tmx function, and creates Sprites for it.
        
        :param map_object: The TileMap read in by read_tmx.
        :param layer_name: The name of the layer that we are creating sprites for.
        :param scaling: Scaling the layer up or down.
                        (Note, any number besides 1 can create a tearing effect,
                        if numbers don't evenly divide.)
        :param base_directory: Base directory of the file, that we start from to
                               load images.
        :param use_spatial_hash: If all, or at least 75%, of the loaded tiles will not
                                 move between frames and you are using either the
                                 simple physics engine or platformer physics engine,
                                 set this to True to speed collision calculation.
                                 Leave False if using PyMunk, if all sprites are moving,
                                 or if no collision will be checked.
        :param str hit_box_algorithm: One of 'None', 'Simple' or 'Detailed'.     Defaults to 'Simple'. Use 'Simple' for the :data:`PhysicsEngineSimple`,     :data:`PhysicsEnginePlatformer`     and 'Detailed' for the :data:`PymunkPhysicsEngine`.
        
            .. figure:: images/hit_box_algorithm_none.png
               :width: 40%
        
               hit_box_algorithm = "None"
        
            .. figure:: images/hit_box_algorithm_simple.png
               :width: 55%
        
               hit_box_algorithm = "Simple"
        
            .. figure:: images/hit_box_algorithm_detailed.png
               :width: 75%
        
               hit_box_algorithm = "Detailed"
        :param float hit_box_detail: Float, defaults to 4.5. Used with 'Detailed' to hit box
        
        :returns: A SpriteList.
    
    quick_run(time_to_pause: numbers.Number)
        Only run the application for the specified time in seconds.
        Useful for unit testing or continuous integration (CI) testing
        where there is no user interaction.
        
        :param Number time_to_pause: Number of seconds to pause before automatically
             closing.
    
    rand_angle_360_deg()
    
    rand_angle_spread_deg(angle: float, half_angle_spread: float) -> float
    
    rand_in_circle(center: Union[Tuple[float, float], List[float]], radius: float)
        Generate a point in a circle, or can think of it as a vector pointing
        a random direction with a random magnitude <= radius
        Reference: http://stackoverflow.com/a/30564123
        Note: This algorithm returns a higher concentration of points around the center of the circle
    
    rand_in_rect(bottom_left: Union[Tuple[float, float], List[float]], width: float, height: float) -> Union[Tuple[float, float], List[float]]
    
    rand_on_circle(center: Union[Tuple[float, float], List[float]], radius: float) -> Union[Tuple[float, float], List[float]]
        Note: by passing a random value in for float, you can achieve what rand_in_circle() does
    
    rand_on_line(pos1: Union[Tuple[float, float], List[float]], pos2: Union[Tuple[float, float], List[float]]) -> Union[Tuple[float, float], List[float]]
    
    rand_vec_magnitude(angle: float, lo_magnitude: float, hi_magnitude: float) -> Union[Tuple[float, float], List[float]]
    
    rand_vec_spread_deg(angle: float, half_angle_spread: float, length: float) -> Union[Tuple[float, float], List[float]]
    
    read_tmx(tmx_file: Union[str, pathlib.Path]) -> pytiled_parser.objects.TileMap
        Given a .tmx, this will read in a tiled map, and return
        a TiledMap object.
        
        Given a tsx_file, the map will use it as the tileset.
        If tsx_file is not specified, it will use the tileset specified
        within the tmx_file.
        
        Important: Tiles must be a "collection" of images.
        
        Hitboxes can be drawn around tiles in the tileset editor,
        but only polygons are supported.
        (This is a great area for PR's to improve things.)
        
        :param str tmx_file: String with name of our TMX file
        
        :returns: Map
        :rtype: TiledMap
    
    render_text(text: arcade.text.CreateText, start_x: float, start_y: float)
        Deprecated. Two step text drawing for backwards compatibility.
    
    rotate_point(x: float, y: float, cx: float, cy: float, angle_degrees: float) -> List[float]
        Rotate a point around a center.
        
        :param x: x value of the point you want to rotate
        :param y: y value of the point you want to rotate
        :param cx: x value of the center point you want to rotate around
        :param cy: y value of the center point you want to rotate around
        :param angle_degrees: Angle, in degrees, to rotate
        :return: Return rotated (x, y) pair
        :rtype: (float, float)
    
    run()
        Run the main loop.
        After the window has been set up, and the event hooks are in place, this is usually one of the last
        commands on the main program.
    
    schedule(function_pointer: Callable, interval: numbers.Number)
        Schedule a function to be automatically called every ``interval``
        seconds.
        
        :param Callable function_pointer: Pointer to the function to be called.
        :param Number interval: Interval to call the function.
    
    screen_to_isometric_grid(screen_x, screen_y, width, height, tile_width, tile_height)
    
    set_background_color(color: Union[Tuple[int, int, int], List[int], Tuple[int, int, int, int]])
        Specifies the background color of the window. This value
        will persist for every future screen clears until changed.
        
        :param Color color: List of 3 or 4 bytes in RGB/RGBA format.
    
    set_viewport(left: float, right: float, bottom: float, top: float)
        This sets what coordinates the window will cover.
        
        By default, the lower left coordinate will be ``(0, 0)`` and the top y
        coordinate will be the height of the window in pixels, and the right x
        coordinate will be the width of the window in pixels.
        
        If a program is making a game where the user scrolls around a larger
        world, this command can help out.
        
        Note: It is recommended to only set the view port to integer values that
        line up with the pixels on the screen. Otherwise if making a tiled game
        the blocks may not line up well, creating rectangle artifacts.
        
        Note: Window.on_resize will call set_viewport by default. If you set your
        own custom viewport, you may need to over-ride this method.
        
        For more advanced users: This functions sets the orthogonal projection
        used by shapes and sprites using the values passed in. it also
        updates the viewport to match the current screen resolution.
        ```window.ctx.projection_2d`` and ``window.ctx.viewport```
        can be used to set viewport and projection separately.
        
        :param Number left: Left-most (smallest) x value.
        :param Number right: Right-most (largest) x value.
        :param Number bottom: Bottom (smallest) y value.
        :param Number top: Top (largest) y value.
    
    set_window(window: pyglet.window.win32.Win32Window)
        Set a handle to the current window.
        
        :param Window window: Handle to the current window.
    
    start_render()
        Get set up to render. Required to be called before drawing anything to the
        screen.
    
    stop_sound(sound: arcade.sound.Sound)
        Stop a sound that is currently playing.
        
        :param sound:
    
    trim_image(image: PIL.Image.Image) -> PIL.Image.Image
        Crops the extra whitespace out of an image.
        
        :returns: New :py:class:`PIL.Image.Image` object.
    
    unschedule(function_pointer: Callable)
        Unschedule a function being automatically called.
        
        :param Callable function_pointer: Pointer to the function to be unscheduled.

DATA
    Color = typing.Union[typing.Tuple[int, int, int], typing.List[int], ty...
    DEFAULT_FONT_NAMES = ('arial.ttf', 'Arial.ttf', 'NotoSans-Regular.ttf'...
    FACE_DOWN = 4
    FACE_LEFT = 2
    FACE_RIGHT = 1
    FACE_UP = 3
    FilenameOrTexture = typing.Union[str, arcade.texture.Texture]
    MOUSE_BUTTON_LEFT = 1
    MOUSE_BUTTON_MIDDLE = 2
    MOUSE_BUTTON_RIGHT = 4
    Point = typing.Union[typing.Tuple[float, float], typing.List[float]]
    PointList = typing.Sequence[typing.Union[typing.Tuple[float, float], t...
    RGB = typing.Union[typing.Tuple[int, int, int], typing.List[int]]
    RGBA = typing.Union[typing.Tuple[int, int, int, int], typing.List[int]...
    Rect = typing.Union[typing.Tuple[float, float, float, float], typing.L...
    RectList = typing.Union[typing.Tuple[typing.Union[typing.Tu...loat, fl...
    TShape = ~TShape
    VERSION = '2.4.3'
    Vector = typing.Union[typing.Tuple[float, float], typing.List[float]]
    __all__ = ['AStarBarrierList', 'AnimatedTimeBasedSprite', 'AnimatedTim...

VERSION
    2.4.3

FILE
    c:\users\\appdata\local\programs\python\python38-32\lib\site-packages\arcade\__init__.py

